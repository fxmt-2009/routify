import "./chunk-V6EME3GZ.js";
import {
  derived,
  writable
} from "./chunk-BGNSNYTR.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  component_subscribe,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  outro_and_destroy_block,
  safe_not_equal,
  setContext,
  set_attributes,
  space,
  subscribe,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-TG5ZCBZ3.js";
import {
  __publicField
} from "./chunk-EA3MIKLP.js";

// node_modules/consolite/esm/index.mjs
var defaults = {
  filter: "",
  level: 3,
  levels: {
    default: 3,
    error: 1,
    warn: 2,
    debug: 4,
    trace: 4
  }
};
var noop2 = (x) => x;
var unique = (v, i, a) => a.indexOf(v) === i;
var escapeRegExp = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
var escapeIfString = (str) => typeof str === "string" ? escapeRegExp(str) : str;
var Consolite = class {
  constructor(...prefix) {
    __publicField(this, "prefix", []);
    __publicField(this, "_filter", null);
    __publicField(this, "_level", null);
    __publicField(this, "_levels", {});
    __publicField(this, "parent", null);
    __publicField(this, "levels", new Proxy(this._levels, {
      ownKeys: (target) => {
        var _a;
        return [
          ...Object.keys(defaults.levels),
          ...Object.keys(((_a = this.parent) == null ? void 0 : _a.levels) || {}),
          ...Reflect.ownKeys(target)
        ].filter(unique);
      },
      getOwnPropertyDescriptor: (target, key) => ({
        value: target[key],
        enumerable: true,
        configurable: true
      }),
      get: (target, prop) => {
        var _a, _b;
        return target[prop] || target.default || ((_a = this.parent) == null ? void 0 : _a.levels[prop]) || ((_b = this.parent) == null ? void 0 : _b.levels.default) || defaults.levels[prop] || defaults.levels.default;
      },
      set: (target, prop, value) => target[prop] = value
    }));
    __publicField(this, "create", createLogger);
    this.prefix.push(...prefix);
    const withinLevel = (prop) => this.levels[prop] <= this.level;
    const passesFilter = () => typeof this.filter === "function" ? this.filter(prefix) : prefix.join("").match(escapeIfString(this.filter));
    this.register = (prop, fn) => Object.defineProperty(this, prop, {
      get: () => {
        const canBind = typeof fn === "function";
        const shouldPrint = withinLevel(prop) && passesFilter() && canBind;
        const prefixes = prefix.map((p) => typeof p === "string" ? p : p(prop, this));
        return shouldPrint ? fn.bind(console, ...prefixes) : noop2;
      }
    });
    Object.keys(console).forEach((prop) => this.register(prop, console[prop]));
  }
  get level() {
    var _a;
    return this._level ?? ((_a = this.parent) == null ? void 0 : _a.level) ?? defaults.level;
  }
  set level(val) {
    this._level = val;
  }
  get filter() {
    var _a;
    return this._filter ?? ((_a = this.parent) == null ? void 0 : _a.filter) ?? defaults.filter;
  }
  set filter(val) {
    this._filter = val;
  }
  get root() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.root) || this;
  }
  createChild(...prefix) {
    const child = createLogger(...this.prefix, ...prefix);
    child.parent = this;
    return child;
  }
  createParent(...prefix) {
    return createLogger(...prefix, ...this.prefix);
  }
};
var createLogger = (...prefix) => Object.assign(new Consolite(...prefix));

// node_modules/@roxi/routify/lib/runtime/utils/logger.js
var log = createLogger("[rf3]");
var createRootLogger = () => {
  Object.assign(log, loadState());
  return new Proxy(log, {
    get: (target, prop) => target[prop],
    set: (target, prop, value) => {
      target[prop] = value;
      saveState(log);
      return true;
    }
  });
};
var loadState = () => {
  if (typeof window === "undefined") {
    const level = process.env.DEBUG_LEVEL;
    const filter = process.env.DEBUG_FILTER;
    return { level, filter };
  } else {
    return JSON.parse(localStorage.getItem("__routify.logState") || "{}");
  }
};
var saveState = (log2) => {
  const { level, filter } = log2;
  if (typeof window === "undefined") {
    process.env.DEBUG_LEVEL = level;
    process.env.DEBUG_FILTER = filter;
  } else
    localStorage.setItem("__routify.logState", JSON.stringify({ filter, level }));
};
var debugWrapper = (fn, msg) => (
  /** @ts-ignore */
  (...params2) => {
    const result = fn(...params2);
    log.debug(msg, { params: params2, result });
    return result;
  }
);

// node_modules/@roxi/routify/lib/runtime/Global/BrowserAdapter.js
var createBrowserAdapter = (opts) => {
  const delimiter = (opts == null ? void 0 : opts.delimiter) || ";";
  return {
    // Called by each router when the browser URL changes. Returns an internal URL for each respective router.
    toRouter: (url2, router) => {
      const formatRE = router.name ? `${router.name}=(.+?)` : `(.+?)`;
      const RE = new RegExp(`(^|${delimiter})${formatRE}(${delimiter}|$)`);
      const matches = url2.match(RE);
      return matches ? matches[2] : "/";
    },
    // compiles all router URLS into a single URL for the browser.
    toBrowser: (routers) => routers.map((r) => (r.name ? `${r.name}=` : "") + r.url.external()).join(delimiter)
  };
};

// node_modules/@roxi/routify/lib/runtime/Global/Global.js
var AppInstance = class {
  constructor() {
    /** @type {RoutifyRuntime[]} */
    __publicField(this, "instances", []);
    /** @type {import('../helpers/preload.js').RoutesMap} */
    __publicField(this, "routeMaps", {});
    __publicField(this, "browserAdapter", createBrowserAdapter());
    /** @param {Router} router */
    __publicField(this, "urlFromBrowser", (router) => {
      if (debugWrapper)
        return debugWrapper(
          this.browserAdapter.toRouter,
          "calling browserAdapter.toRouter"
        )(urlFromAddress(), router);
      return this.browserAdapter.toRouter(urlFromAddress(), router);
    });
    globalThis["__routify"] = this;
    this.log = createRootLogger();
  }
  /** @type {Router[]} */
  get routers() {
    return [].concat(...this.instances.map((instance8) => instance8.routers));
  }
  register(instance8) {
    this.instances.push(instance8);
    return this;
  }
};
var appInstance = new AppInstance();

// node_modules/@roxi/routify/lib/runtime/utils/index.js
var CTX = "routify-fragment-context";
var getRoutifyFragmentContext = () => getContext(CTX);
var getRoutifyFragmentContextMaybe = () => {
  try {
    const ctx = getRoutifyFragmentContext();
    return ctx;
  } catch (e) {
  }
};
var setRoutifyFragmentContext = (value) => setContext(CTX, value);
var shouldIgnoreClick = (event) => event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button || event.key && event.key !== "Enter" || event.defaultPrevented;
var parseValue = (value) => {
  try {
    return JSON.parse(value);
  } catch (error) {
    return value;
  }
};
var extractRoutifyStateData = (el) => {
  const routifyRouteState = {};
  for (let key in el.dataset) {
    if (key.startsWith("routifyRouteState")) {
      const shortKey = key.replace("routifyRouteState", "");
      const finalKey = shortKey.charAt(0).toLowerCase() + shortKey.slice(1);
      routifyRouteState[finalKey] = parseValue(el.dataset[key]);
    }
  }
  return routifyRouteState;
};
var getUrlFromEvent = (event) => {
  const el = event.target.closest("a");
  const href = el && el.href;
  if (!href || el.target || el.host !== location.host)
    return {};
  const urlObj = new URL(href);
  event.preventDefault();
  return {
    url: urlObj.pathname + urlObj.search + urlObj.hash,
    state: extractRoutifyStateData(el)
  };
};
var fromEntries = (iterable) => {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val;
    return obj;
  }, {});
};
var populateUrl = (path, params2, route) => {
  const overloads = {};
  Object.entries(params2).forEach(([param, value]) => {
    const RE = new RegExp(`\\[(...)?${param}\\]|\\:${param}`);
    value = Array.isArray(value) ? value.join("/") : value;
    if (path.match(RE))
      path = path.replace(RE, encodeURI(value));
    else
      overloads[param] = value;
  });
  const query = route.router.queryHandler.stringify(overloads, route);
  return path + query;
};
var urlFromAddress = () => (({ pathname, search, hash }) => pathname + search + hash)(window.location);
var getGlobalContext = () => {
  console.log("Using helpers outside router context is not supported. Use at own risk.");
  const router = appInstance.routers[0];
  const route = router.activeRoute.get() || router.pendingRoute.get();
  return {
    elem: null,
    anchorLocation: null,
    options: null,
    childFragments: writable(route.allFragments),
    node: router.rootNode,
    fragment: route.allFragments[0],
    isActive: writable(false),
    isVisible: writable(false),
    inline: null,
    router,
    route,
    parentContext: null,
    onDestroy: null,
    decorators: [],
    scrollBoundary: null,
    isInline: null,
    mounted: null
  };
};
var contexts = {
  /** @type {Router} */
  get router() {
    return (getRoutifyFragmentContext() || getGlobalContext()).router;
  },
  /** @type {RenderContext} */
  get fragment() {
    return getRoutifyFragmentContext() || getGlobalContext();
  }
};
var getable = (value, start) => {
  const store = writable(value, start);
  return Object.assign(store, { get: () => get_store_value(store) });
};
var identicalRoutes = (...routes) => routes.map((route) => JSON.stringify([route == null ? void 0 : route.allFragments, route == null ? void 0 : route.url])).reduce((prev, curr) => prev === curr && curr);
var isAnonFn = (input) => typeof input === "function" && !input.prototype;
var resolveIfAnonFn = (subject, params2) => isAnonFn(subject) ? (
  /** @type {any} */
  subject(...params2)
) : subject;
var pushToOrReplace = (arr, input) => {
  const _isAnonFn = isAnonFn(input);
  input = _isAnonFn || Array.isArray(input) ? input : [input];
  const res = _isAnonFn ? input([...arr]) : [...arr, ...input];
  if (!Array.isArray(res))
    throw new Error("anonymous callback did not return array");
  return res;
};
var waitFor = (store, cb) => new Promise((resolve, reject) => {
  try {
    const unsub = store.subscribe((val) => {
      if (cb(val)) {
        resolve(val);
        setTimeout(() => unsub);
      }
    });
  } catch (err) {
    reject(err);
  }
});
var createDeferredPromise = () => {
  let resolve, reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  return Object.assign(promise, { resolve, reject });
};

// node_modules/@roxi/routify/lib/runtime/utils/messages.js
var couldNotFindRoutes = (name) => `Could not find routes for the router '${name}'. Please use the 'routes' prop or create a route tree named '${name}'.
Eg. routesDir: {
    default: 'src/routes',
    ${name}: 'src/widget',
}`;
var noRoutesMapProvided = (name) => `No routesMap provided. Make sure you've either created a router for the '${name}' route or provided a routesMap`;
var handleRebuildError = (context2, childContexts) => {
  console.warn("Failed to rebuild routes", { context: context2, childContexts });
  const msg = "Infinite loop detected while trying to compose components. This is likely an error in Routify.";
  const err = new Error(msg);
  throw err;
};

// node_modules/@roxi/routify/lib/runtime/helpers/preload.js
var preloadUrl = (urlOrOptions) => {
  var _a;
  const options = typeof urlOrOptions === "string" || Array.isArray(urlOrOptions) ? { url: urlOrOptions } : urlOrOptions;
  let { url: url2, routesMap } = options;
  url2 = url2 || (((_a = import.meta["env"]) == null ? void 0 : _a.SSR) ? import.meta["env"].URL : typeof window != "undefined" ? window.location.pathname + window.location.search + window.location.hash : "");
  const urls = Array.isArray(url2) ? url2 : [url2];
  return Promise.all(
    urls.map((url3) => preloadUrlFromUrlPairs(getUrlSegments(url3), routesMap))
  );
};
var createNewRouter = async (name, url2, routesMap) => {
  const fullName = name || "default";
  if (!routesMap)
    console.error(noRoutesMapProvided(fullName));
  const getRoutes = routesMap[fullName];
  if (!getRoutes) {
    console.error(couldNotFindRoutes(fullName));
    return false;
  }
  return createRouter({ name, url: url2, routes: await getRoutes() });
};
var preloadUrlFromUrlPairs = async (urlPairs, routesMap) => {
  const routerPromises = urlPairs.map(async ([name, url2]) => {
    const matchingRouter = appInstance.routers.find((router2) => router2.name === name);
    const router = matchingRouter || await createNewRouter(name, url2, routesMap);
    if (!router)
      return false;
    const currentRoute = router.pendingRoute.get() || router.activeRoute.get();
    if ((currentRoute == null ? void 0 : currentRoute.url) !== url2)
      router.url.replace(url2);
    return router;
  });
  const routers = await Promise.all(routerPromises);
  await Promise.all(routers.map((router) => router && router.ready()));
  return routers.map((router) => router.activeRoute.get().load);
};
var getUrlSegments = (compositeUrl) => compositeUrl.split(";").map(urlSegmentToRouterAndUrl);
var urlSegmentToRouterAndUrl = (urlSegment, index) => {
  if (!index)
    return ["", urlSegment];
  const matches = urlSegment.match(/([\w-]+?)=(.+)/);
  return [matches[1], matches[2]];
};
var getPrimaryUrl = (urlPairs) => urlPairs.find(([name]) => name === "")[1];

// node_modules/@roxi/routify/lib/runtime/helpers/index.js
var getMRCA = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  return lineage1.find((node3) => lineage2.includes(node3));
};
var getPath = (node1, node2) => {
  const lineage1 = [node1, ...node1.ancestors];
  const lineage2 = [node2, ...node2.ancestors];
  const mrca = getMRCA(node1, node2);
  const backtrackSteps = lineage1.indexOf(mrca);
  const backtrackStr = backtrackSteps ? "../".repeat(backtrackSteps) : "";
  const forwardSteps = lineage2.indexOf(mrca);
  const forwardStepsStr = lineage2.slice(0, forwardSteps).reverse().map((n) => n.name).join("/");
  return backtrackStr + forwardStepsStr;
};
var goto = {
  subscribe: (run, invalidate) => {
    const { router } = contexts;
    return derived(url, ($url) => (path, userParams, options) => {
      const defaults2 = { mode: "push", state: {} };
      options = { ...defaults2, ...options };
      const newUrl = $url(path, userParams, options);
      router.url[options.mode](newUrl, options.state);
    }).subscribe(run, invalidate);
  }
};
var _url = {
  subscribe: (run, invalidate) => {
    const { router } = contexts;
    const originalOriginNode = contexts.fragment.node;
    return derived(router.activeRoute, (activeRoute2) => {
      const originNode = router.rootNode.traverse(originalOriginNode.path);
      return createUrl(router, originNode, activeRoute2);
    }).subscribe(run, invalidate);
  }
};
var url = {
  subscribe: (run, invalidate) => {
    let InitialElem, initialParams, initialPath;
    const updateHref = ($url) => InitialElem.setAttribute("href", $url(initialPath, ...initialParams));
    return derived(_url, ($url) => {
      if (InitialElem) {
        updateHref($url);
      }
      return (pathOrElem, ...params2) => {
        if (typeof pathOrElem != "object") {
          return $url(pathOrElem, ...params2);
        }
        InitialElem = pathOrElem;
        initialParams = params2;
        initialPath = InitialElem.getAttribute("href");
        updateHref($url);
      };
    }).subscribe(run, invalidate);
  }
};
var createUrl = (router, originNode, activeRoute2) => (
  /** @type {UrlFromString} */
  (inputPath, userParams = {}, options = {}) => {
    inputPath = inputPath.replace("$leaf", activeRoute2.url);
    const offset = inputPath.startsWith("/") ? router.rootNode.path : "";
    const targetNode = originNode.traverse(
      offset + inputPath,
      // path
      !options.strict,
      // allowDynamic
      options.includeIndex,
      // includeIndex
      options.silent
      // silent
    );
    if (!targetNode) {
      console.error("could not find destination node", inputPath);
      return;
    }
    const mrca = getMRCA(targetNode, router.rootNode);
    const path = ("/" + getPath(mrca, targetNode)).replace(/\/index$/, "/");
    const params2 = {
      ...inheritedParams(targetNode, activeRoute2),
      ...userParams
    };
    const internalUrl = populateUrl(path, params2, activeRoute2);
    const externalUrl = router.getExternalUrl(internalUrl);
    return externalUrl;
  }
);
var inheritedParams = (node2, route) => {
  const lineage = [node2, ...node2.ancestors].reverse();
  const params2 = lineage.map(
    (_node) => {
      var _a;
      return (_a = route.allFragments.find(
        // compare both path and node
        // node could have moved /shop/[product], eg: to /en/shop/[product]
        // but could also have been replaced by a different, but matching node
        // if the route tree changed, eg: /en/shop/[product] /da/shop/[product]
        (fragment) => fragment.node === _node || fragment.node.path === _node.path
      )) == null ? void 0 : _a.params;
    }
  );
  return Object.assign({}, ...params2);
};
var params = {
  subscribe: (run, invalidate) => derived(contexts.router.params, (params2) => params2).subscribe(run, invalidate)
};
var isActive = {
  subscribe: (run, invalidate) => {
    const { fragment, router } = contexts;
    return derived(router.activeRoute, () => isActiveUrl(fragment)).subscribe(
      run,
      invalidate
    );
  }
};
var isActiveUrl = (renderContext) => {
  const { router, fragment } = renderContext;
  return (path, params2 = {}, options = {}) => {
    const { recursive } = { recursive: true, ...options };
    const route = router.activeRoute.get();
    const chainOptions = {
      rootNode: router.rootNode,
      allowDynamic: false,
      includeIndex: false
    };
    const allWantedParamsAreInActiveChain = Object.entries(params2).every(
      ([key, value]) => route.params[key] === value
    );
    if (!allWantedParamsAreInActiveChain)
      return false;
    const wantedNode = path.startsWith(".") ? fragment.node.traverse(path) : router.rootNode.getChainTo(path, chainOptions).pop().node;
    const actNodes = [...route.fragments.map((fragment2) => fragment2.node)].reverse();
    return recursive ? actNodes.includes(wantedNode) : actNodes.pop() === wantedNode;
  };
};
var resolveNode = (path) => {
  const { node: node2 } = contexts.fragment;
  const { router } = contexts;
  return traverseNode(node2, path, router);
};
var traverseNode = (node2, path, router) => path.startsWith("/") ? router.rootNode.traverse(`.${path}`) : node2.traverse(path);
var pseudoStore = (callback) => ({
  subscribe: (run) => {
    run(callback());
    return () => {
    };
  }
});
var context = pseudoStore(() => contexts.fragment);
var node = pseudoStore(() => get_store_value(context).node);
var meta = pseudoStore(() => get_store_value(node).meta);
var activeRoute = {
  subscribe: (run) => contexts.router.activeRoute.subscribe(run)
};
var pendingRoute = {
  subscribe: (run) => contexts.router.pendingRoute.subscribe(run)
};
var afterUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.afterUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};
var beforeUrlChange = {
  subscribe: (run) => {
    const hookHandles = [];
    const register = (callback) => {
      const unhook = contexts.router.beforeUrlChange(callback);
      hookHandles.push(unhook);
      return unhook;
    };
    run(register);
    return () => hookHandles.map((unhook) => unhook());
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/utils.js
var uriDecodeStringOrArray = (strOrArr) => strOrArr instanceof Array ? (
  /** @type {T} */
  strOrArr.map(decodeURI)
) : (
  /** @type {T} */
  decodeURI(strOrArr)
);
var URIDecodeObject = (obj) => Object.entries(obj).reduce(
  (_return, [key, value]) => ({
    ..._return,
    [key]: uriDecodeStringOrArray(value)
  }),
  {}
);
var LoadCache = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * Fetches data for the given ID and caches it.
   * @param {any} id
   * @param {LoadCacheFetchOptions<P>} options
   * @returns {Promise<P>}
   */
  async fetch(id, options) {
    if (!this.map.has(id))
      this.map.set(id, options.hydrate());
    this._handlePromise(id, options);
    return this.map.get(id);
  }
  /**
   * Handles the Promise resolution, cache expiration, and cache clearing.
   * @param {any} id
   * @param {LoadCacheFetchOptions<P>} options
   */
  async _handlePromise(id, options) {
    var _a;
    const value = await this.map.get(id);
    const clear = (_a = options.clear) == null ? void 0 : _a.call(options, value);
    if (typeof clear === "number")
      setTimeout(() => this.map.delete(id), clear);
    else if (clear)
      this.map.delete(id);
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/RouteFragment.js
var RouteFragment = class {
  /**
   * @param {Route} route the route this fragment belongs to
   * @param {RNodeRuntime} node the node that corresponds to the fragment
   * @param {String=} urlFragment a fragment of the url (fragments = url.split('/'))
   * @param {Object<string, any>=} params
   */
  constructor(route, node2, urlFragment = "", params2 = {}) {
    /**
     * @type {Object.<string, string|string[]>}
     **/
    __publicField(this, "_params", {});
    this.route = route;
    this.node = node2;
    this.load = void 0;
    this.urlFragment = urlFragment;
    this.params = params2;
    this.renderContext = createDeferredPromise();
    Object.defineProperty(this, "route", { enumerable: false });
  }
  get params() {
    return URIDecodeObject(this._params);
  }
  set params(params2) {
    this._params = params2;
  }
};

// node_modules/@roxi/routify/lib/runtime/Route/Route.js
var URL_STATES = ["pushState", "replaceState", "popState"];
var loadCache = new LoadCache();
var Route = class {
  /**
   * @param {Router} router
   * @param {string} url
   * @param {UrlState} mode
   * @param {Object} state a state to attach to the route
   */
  constructor(router, url2, mode, state = {}) {
    /** @type {RouteFragment[]} */
    __publicField(this, "allFragments", []);
    /** @type {RouteFragment[]} only fragments with components */
    __publicField(this, "fragments", []);
    /** @type {RoutifyLoadReturn} */
    __publicField(this, "load", {
      status: 200,
      error: null,
      maxage: null,
      props: {},
      redirect: null
    });
    const [, hash] = url2.match(/#(.+)/) || [];
    this.router = router;
    this.url = url2;
    this.mode = mode;
    this.state = state;
    this.hash = hash;
    this.state.createdAt = /* @__PURE__ */ new Date();
    if (!router.rootNode) {
      const err = new Error(
        "Can't navigate without a rootNode. Have you imported routes?"
      );
      Object.assign(err, { routify: { router } });
      throw err;
    }
    if (!URL_STATES.includes(mode))
      throw new Error("url.mode must be pushState, replaceState or popState");
    this.allFragments = this._createFragments();
    this.fragments = this.router.transformFragments.run(this.allFragments);
    this.log = router.log.createChild("[route]");
    this.log.debug("created", this);
  }
  get params() {
    const match = this.url.match(/\?.+/);
    const query = match && match[0] || "";
    return Object.assign(
      {},
      ...this.allFragments.map((fragment) => fragment.params),
      this.router.queryHandler.parse(query, this)
    );
  }
  get leaf() {
    return [...this.fragments].pop();
  }
  get isPendingOrPrefetch() {
    return this === this.router.pendingRoute.get() || this.state.prefetch;
  }
  async loadRoute() {
    const pipeline = [
      this.runBeforeUrlChangeHooks,
      this.loadComponents,
      this.runPreloads
    ];
    for (const pretask of pipeline) {
      const passedPreTask = await pretask.bind(this)();
      if (!this.isPendingOrPrefetch || !passedPreTask)
        return false;
    }
    this.log.debug("loaded route", this);
    return true;
  }
  /**
   * converts async module functions to sync functions
   */
  async loadComponents() {
    this.log.debug("load components", this);
    const nodes = this.fragments.map((fragment) => fragment.node);
    const multiNodes = nodes.map((node2) => node2.children.find((node3) => node3.name === "_decorator")).filter(Boolean);
    await Promise.all([...nodes, ...multiNodes].map((node2) => node2.loadModule()));
    return true;
  }
  async runPreloads() {
    var _a;
    this.log.debug("run preloads", this);
    const prevRoute = this.router.activeRoute.get();
    for (const [index, fragment] of this.fragments.entries()) {
      if (!this.isPendingOrPrefetch)
        return false;
      const prevFragmentInSpot = prevRoute == null ? void 0 : prevRoute.fragments[index];
      const isSameBranch = fragment.node === (prevFragmentInSpot == null ? void 0 : prevFragmentInSpot.node);
      const ctx = {
        route: this,
        url: createUrl(this.router, fragment.node, this),
        prevRoute,
        isNew: !isSameBranch,
        fetch
      };
      if ((_a = fragment.node.module) == null ? void 0 : _a.load) {
        const cacheId = JSON.stringify([this.params, fragment.node.id]);
        const load = await loadCache.fetch(cacheId, {
          hydrate: () => fragment.node.module.load(ctx),
          // if no expire is set clear it on load, unless it's a prefetch
          clear: (res) => (res == null ? void 0 : res.expire) || !this.state.prefetch
        });
        fragment.load = {
          ...isSameBranch && prevFragmentInSpot.load,
          ...load
        };
        Object.assign(this.load, fragment.load);
        if (this.load.redirect && !this.state.prefetch)
          return this.router.url.replace(this.load.redirect, {
            redirectedBy: this
          });
      }
    }
    return this;
  }
  async runBeforeUrlChangeHooks() {
    return await this.router.beforeUrlChange.run({ route: this });
  }
  get meta() {
    return this.fragments.reduce((acc, curr) => ({ ...acc, ...curr.node.meta }), {});
  }
  /**
   * @param {RNodeRuntime} node the node that corresponds to the fragment
   * @param {String=} urlFragment a fragment of the url (fragments = url.split('/'))
   * @param {Object<string, any>=} params
   */
  createFragment(node2, urlFragment = "", params2 = {}) {
    return new RouteFragment(this, node2, urlFragment, params2);
  }
  /**
   * creates fragments. A fragment is the section between each / in the URL
   */
  _createFragments() {
    const url2 = this.url.replace(/[#?].+/, "");
    const rootNode = this.router.rootNode;
    const nodeChain = this.router.rootNode.getChainTo(url2, {
      rootNode,
      allowDynamic: true,
      includeIndex: true
    });
    const fragments = nodeChain.map(
      (nc) => this.createFragment(nc.node, nc.fragment, nc.params)
    );
    return fragments;
  }
};

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/ReflectorBase.js
var BaseReflector = class {
  /** @param {Router} router */
  constructor(router) {
    this.router = router;
    this.log = this.router.log;
  }
  install() {
  }
  uninstall() {
  }
  reflect() {
  }
};

// node_modules/@roxi/routify/lib/common/RNode.js
var RNode = class {
  /**
   * @param {string} name
   * @param {ReservedCmpProps|string} module
   * @param {InstanceType} instance
   */
  constructor(name, module, instance8) {
    /** @type {InstanceType['NodeType']} */
    __publicField(this, "parent");
    /** @type {Object.<string, any>} */
    __publicField(this, "meta", {});
    /** @type {String} */
    __publicField(this, "id");
    /** @type {Object.<string,RegExp>} */
    __publicField(this, "_regex", {});
    /**
     * @type {Object.<string, string[]>}
     * */
    __publicField(this, "_paramKeys", {});
    this.instance = instance8;
    this.name = name || "";
    instance8.nodeIndex.push(this);
    this.module = module;
    Object.defineProperty(this, "instance", { enumerable: false });
    Object.defineProperty(this, "parent", { enumerable: false });
  }
  /** @param {InstanceType['NodeConstructor']['prototype']} child */
  appendChild(child) {
    if (child.instance)
      child.parent = this;
  }
  /**
   * Creates a new child node
   * Same as `node.appendChild(instance.createNode('my-node'))`
   * @param {string} name
   */
  createChild(name, module) {
    const node2 = (
      /** @type {InstanceType['NodeConstructor']['prototype']} */
      this.instance.createNode(name, module)
    );
    this.appendChild(node2);
    return node2;
  }
  /** @type {InstanceType['NodeConstructor']['prototype'][]} */
  get descendants() {
    return this.instance.nodeIndex.filter(
      (node2) => node2.ancestors.find((n) => n === this)
    );
  }
  remove() {
    const { nodeIndex } = this.instance;
    const index = nodeIndex.findIndex((node2) => node2 === this);
    nodeIndex.splice(index, 1);
  }
  /** @type {InstanceType['NodeConstructor']['prototype'][]} */
  get ancestors() {
    let node2 = this;
    const ancestors = [];
    while (node2 = node2.parent)
      ancestors.push(node2);
    return ancestors;
  }
  /** @type {InstanceType['NodeConstructor']['prototype']} */
  get root() {
    let node2 = this;
    while (node2.parent)
      node2 = node2.parent;
    return node2;
  }
  get isRoot() {
    return this === this.root;
  }
  /** @type {InstanceType['NodeType'][]} */
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this);
  }
  /** @returns {number} */
  get level() {
    var _a;
    return (((_a = this.parent) == null ? void 0 : _a.level) || 0) + 1;
  }
  get regex() {
    const { name } = this;
    if (!this._regex[name])
      this._regex[name] = this.instance.utils.getRegexFromName(this.name);
    return this._regex[name];
  }
  // save to regex key so regex gets invalidated if name changes
  set regex(value) {
    this._regex[this.name] = new RegExp(value);
  }
  get paramKeys() {
    const { name } = this;
    if (!this._paramKeys[name])
      this._paramKeys[name] = this.instance.utils.getFieldsFromName(name);
    return this._paramKeys[name];
  }
  /**
   * returns parameters for a given urlFragment
   * @param {string} urlFragment
   */
  getParams(urlFragment) {
    if (urlFragment.match(/^\.+$/))
      return {};
    const values = this.instance.utils.getValuesFromPath(this.regex, urlFragment);
    return this.instance.utils.mapFieldsWithValues(this.paramKeys, values);
  }
  // todo traverse should use the getChainTo API interface
  /**
   * resolve a node relative to this node
   * @param {string} path
   * @param {boolean} allowDynamic allow traversing dynamic components (parameterized)
   * @param {boolean} includeIndex
   * @param {boolean} silent don't throw errors for 404s
   * @returns {this}
   */
  traverse(path, allowDynamic = false, includeIndex = false, silent = false) {
    var _a;
    const isNamed = !path.startsWith("/") && !path.startsWith(".");
    return isNamed ? this.root.instance.nodeIndex.find((node2) => node2.meta.name === path) : (_a = this.getChainTo(path, { allowDynamic, includeIndex, silent })) == null ? void 0 : _a.pop().node;
  }
  /**
   * Returns an array of steps to reach a path. Each path contains a node and params
   * @param {string} path
   * @param {object} [options]
   * @param {boolean} [options.allowDynamic=true]
   * @param {boolean} [options.includeIndex=true]
   * @param {boolean} [options.silent=false] don't throw errors for 404s
   * @param {this} [options.rootNode]
   
   */
  getChainTo(path, options) {
    options = {
      ...{ allowDynamic: true, includeIndex: true },
      ...options
    };
    const originNode = path.startsWith("/") ? options.rootNode || this.root : this;
    const stepsToLeaf = path.split("/").filter((snip) => snip !== ".").filter(Boolean);
    let currentNodeStep = {
      node: originNode,
      stepsToLeaf,
      params: {},
      fragment: ""
    };
    const nodeSteps = [currentNodeStep];
    let inStaticDeadEnd = false;
    let inDynamicDeadEnd = false;
    while (currentNodeStep.stepsToLeaf.length) {
      const [nextStep, ...restSteps] = currentNodeStep.stepsToLeaf;
      const nextNode = nextStep === ".." ? currentNodeStep.node.parent : !inStaticDeadEnd && currentNodeStep.node.children.find(
        (node2) => node2.name === nextStep
      ) || options.allowDynamic && !inDynamicDeadEnd && currentNodeStep.node.children.filter(({ meta: meta2 }) => meta2.dynamic && !meta2.dynamicSpread).find((node2) => node2.regex.test(nextStep)) || options.allowDynamic && currentNodeStep.node.children.find(
        (node2) => node2.meta.dynamicSpread
      );
      if (nextNode) {
        const nodeStep = {
          node: nextNode,
          params: nextNode.meta.dynamicSpread ? [nextStep] : nextNode.meta.dynamic ? nextNode.getParams(nextStep) : {},
          stepsToLeaf: restSteps,
          fragment: nextStep
        };
        currentNodeStep = nodeStep;
        nodeSteps.push(nodeStep);
      } else if (!options.allowDynamic && options.silent)
        return null;
      else if (!options.allowDynamic && !options.silent)
        throw new Error(
          `${nodeSteps.map((ns) => ns.node.name || "root").join("/")} could not travel to ${nextStep}`
        );
      else if (currentNodeStep.node.meta.dynamicSpread) {
        currentNodeStep.params.push(nextStep);
        currentNodeStep.fragment += `/${nextStep}`;
        currentNodeStep.stepsToLeaf.shift();
        inDynamicDeadEnd = false;
        inStaticDeadEnd = false;
      } else {
        nodeSteps.pop();
        currentNodeStep = [...nodeSteps].pop();
        inDynamicDeadEnd = inStaticDeadEnd;
        inStaticDeadEnd = true;
        if (!currentNodeStep && options.silent)
          return null;
        else if (!currentNodeStep && !options.silent)
          throw new Error(`Could not find path "${path}" from ${this.name}`);
      }
    }
    try {
      const indexNode = options.includeIndex && currentNodeStep.node.traverse("./index");
      if (indexNode)
        nodeSteps.push({
          node: indexNode,
          stepsToLeaf: [],
          params: {},
          fragment: ""
        });
    } catch (err) {
    }
    nodeSteps.forEach((ns) => {
      ns.params = Array.isArray(ns.params) ? { [ns.node.name.replace(/\[\.\.\.(.+)\]/, "$1")]: ns.params } : ns.params;
    });
    return nodeSteps;
  }
  /** @returns {InstanceType['NodeConstructor']['prototype']} */
  toJSON() {
    return {
      ...this,
      children: [...this.children]
    };
  }
  /** @returns {string} */
  get path() {
    return "/" + [this, ...this.ancestors].reverse().map((node2) => node2.name).filter(Boolean).join("/");
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/Node.svelte
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(21:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*passthrough*/
    ctx[0],
    { context: (
      /*context*/
      ctx[2]
    ) }
  ];
  var switch_value = (
    /*Component*/
    ctx[1]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty & /*passthrough, context*/
    5) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty & /*passthrough*/
        1 && get_spread_object(
          /*passthrough*/
          ctx2[0]
        ),
        dirty & /*context*/
        4 && { context: (
          /*context*/
          ctx2[2]
        ) }
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*Component*/
      2 && switch_value !== (switch_value = /*Component*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*passthrough, context*/
        5 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*passthrough*/
          1 && get_spread_object(
            /*passthrough*/
            ctx2[0]
          ),
          dirty & /*context*/
          4 && { context: (
            /*context*/
            ctx2[2]
          ) }
        ]) : {};
        if (dirty & /*$$scope*/
        32) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(17:0) {#if Component}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[5],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        32)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[5],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[5]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[5],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(18:4) <svelte:component this={Component} {...passthrough} {context}>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*Component*/
      ctx2[1]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Node", slots, ["default"]);
  let { node: node2 } = $$props;
  let { passthrough } = $$props;
  const context2 = { ...getRoutifyFragmentContext(), node: node2 };
  setRoutifyFragmentContext(context2);
  let Component = (_a = node2.module) == null ? void 0 : _a.default;
  if (!Component && node2.asyncModule)
    node2.asyncModule().then((r) => $$invalidate(1, Component = r.default));
  $$self.$$.on_mount.push(function() {
    if (node2 === void 0 && !("node" in $$props || $$self.$$.bound[$$self.$$.props["node"]])) {
      console.warn("<Node> was created without expected prop 'node'");
    }
    if (passthrough === void 0 && !("passthrough" in $$props || $$self.$$.bound[$$self.$$.props["passthrough"]])) {
      console.warn("<Node> was created without expected prop 'passthrough'");
    }
  });
  const writable_props = ["node", "passthrough"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Node> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("$$scope" in $$props2)
      $$invalidate(5, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getRoutifyFragmentContext,
    setRoutifyFragmentContext,
    node: node2,
    passthrough,
    context: context2,
    Component
  });
  $$self.$inject_state = ($$props2) => {
    if ("node" in $$props2)
      $$invalidate(3, node2 = $$props2.node);
    if ("passthrough" in $$props2)
      $$invalidate(0, passthrough = $$props2.passthrough);
    if ("Component" in $$props2)
      $$invalidate(1, Component = $$props2.Component);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [passthrough, Component, context2, node2, slots, $$scope];
}
var Node = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { node: 3, passthrough: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Node",
      options,
      id: create_fragment.name
    });
  }
  get node() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set node(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Node>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Node>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Node_default = Node;

// node_modules/@roxi/routify/lib/runtime/Instance/RNodeRuntime.js
var RNodeRuntime = class extends RNode {
  /**
   * @param {string} name
   * @param {ReservedCmpProps} module
   * @param {RoutifyRuntime} instance
   * @param {LoadSvelteModule=} asyncModule
   */
  constructor(name, module, instance8, asyncModule) {
    super(name, module, instance8);
    /** @type {LoadSvelteModule} */
    __publicField(this, "asyncModule");
    /**
     * @param {object} snapshotRoot
     */
    __publicField(this, "importTree", (snapshotRoot) => {
      const queue = [[this, snapshotRoot]];
      while (queue.length) {
        const [node2, snapshot] = queue.pop();
        const { children: children2, ...nodeSnapshot } = snapshot;
        Object.assign(node2, nodeSnapshot);
        for (const childSnapshot of children2) {
          const childNode = node2.createChild(
            snapshot.name || snapshot.rootName || ""
          );
          queue.push([childNode, childSnapshot]);
        }
      }
      return this;
    });
    this.module = module;
    this.asyncModule = asyncModule;
  }
  get children() {
    return this.instance.nodeIndex.filter((node2) => node2.parent === this).sort((prev, curr) => (prev.meta.order || 0) - (curr.meta.order || 0));
  }
  get pages() {
    return this.pagesWithIndex.filter((node2) => node2.name !== "index");
  }
  /**
   * Returns the title of the node. Looks for meta.title, falls back to capitalized name
   * Can be transformed with the router transformTitle hook
   * @returns {string}
   */
  get title() {
    const getPrettyName = () => this.name.replace(/-/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
    const getTitle = () => this.meta.title || getPrettyName();
    return getTitle();
  }
  get pagesWithIndex() {
    return this.children.filter((node2) => !node2.meta.fallback).filter((node2) => !node2.name.startsWith("_")).filter((node2) => !node2.name.includes("[")).filter((node2) => {
      var _a;
      return !(((_a = node2.meta) == null ? void 0 : _a.order) === false);
    });
  }
  get hasComponent() {
    return !!(this.module || this.asyncModule);
  }
  /** @ts-ignore SvelteComponentConstructor is only available in VSCode */
  /** @returns {Promise<SvelteComponentDev>} */
  async getRawComponent() {
    const module = await this.loadModule();
    return module == null ? void 0 : module.default;
  }
  async loadModule() {
    if (!this.module && this.asyncModule) {
      let childPromises = [];
      if (this.meta.bundle || typeof window === "undefined")
        childPromises = this.children.map((c) => c.loadModule());
      [this.module] = await Promise.all([this.asyncModule(), ...childPromises]);
    }
    return this.module;
  }
  /**
   * Returns in a sync/async component in a synchronous wrapper
   * @returns {() => Node}
   **/
  get component() {
    const node2 = this;
    return function(options) {
      options.props = {
        ...options.props,
        passthrough: options.props,
        node: node2
      };
      return new Node_default({ ...options });
    };
  }
  get _fallback() {
    var _a;
    return this.children.find((node2) => node2.meta.fallback) || ((_a = this.parent) == null ? void 0 : _a._fallback);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/UrlParamUtils.js
var defaultRe = /\[(.+?)\]/gm;
var UrlParamUtils = class {
  constructor(RE = defaultRe) {
    /**
     * returns ["slug", "id"] from "my[slug]and[id]"
     * @param {string} name
     * @returns {string[]}
     */
    __publicField(this, "getFieldsFromName", (name) => [...name.matchAll(this.RE)].map((v) => v[1]));
    /**
     * converts "my[slug]and[id]" to /my(.+)and(.+)/gm
     * @param {string} name
     * @returns {RegExp}
     */
    __publicField(this, "getRegexFromName", (name) => new RegExp("^" + name.replace(this.RE, "(.+)") + "$"));
    /**
     * returns an array of values matching a regular expression and path
     * @param {RegExp} re
     * @param {string} path
     * @returns {string[]}
     */
    __publicField(this, "getValuesFromPath", (re, path) => (path.match(re) || []).slice(1));
    /**
     * converts (['a', 'b', 'c'], [1, 2, 3]) to {a: 1, b: 2, c: 3}
     * @param {string[]} fields
     * @param {string[]} values
     * @returns
     */
    __publicField(this, "mapFieldsWithValues", (fields, values) => this.haveEqualLength(fields, values) && fields.reduce((map, field, index) => {
      map[field] = values[index];
      return map;
    }, {}));
    __publicField(this, "haveEqualLength", (fields, values) => {
      if (fields.length !== values.length)
        throw new Error(
          `fields and values should be of same length
fields: ${JSON.stringify(fields)}
values: ${JSON.stringify(values)}`
        );
      return true;
    });
    this.RE = RE;
  }
};

// node_modules/@roxi/routify/lib/common/Routify.js
var Routify = class {
  constructor() {
    /** @type {typeof RNode<any>} */
    __publicField(this, "NodeConstructor");
    /** @type {NodeConstructor['prototype']} */
    __publicField(this, "NodeType");
    /** @type {NodeConstructor['prototype'][]} */
    __publicField(this, "nodeIndex", []);
    /** @type {Object<string, NodeConstructor['prototype']>} */
    __publicField(this, "rootNodes", {});
    __publicField(this, "utils", new UrlParamUtils());
  }
  /**
   * @param {string=} name relative path for the node
   * @param {any|string=} module svelte component
   * @returns {this['NodeType']}
   */
  createNode(name, module) {
    return new this.NodeConstructor(name, module, this);
  }
};

// node_modules/@roxi/routify/lib/runtime/Instance/RoutifyRuntime.js
var RoutifyRuntime = class extends Routify {
  constructor(options) {
    super();
    __publicField(this, "NodeConstructor", RNodeRuntime);
    __publicField(this, "mode", "runtime");
    /**@type {Router[]} routers this instance belongs to */
    __publicField(this, "routers", []);
    /** @type {Object<string, RNodeRuntime>} */
    __publicField(this, "rootNodes", {});
    this.options = options;
    if (options.routes) {
      this.rootNodes[options.routes.rootName || "unnamed"] = this.createNode(
        options.routes.rootName
      ).importTree(options.routes);
    }
    this.global = appInstance.register(this);
    Object.defineProperty(this, "routers", { enumerable: false });
    this.log = this.global.log;
  }
};

// node_modules/hookar/esm/util.mjs
var runOnce = (cb) => {
  let hasRun;
  const wrapper = (...params2) => {
    if (hasRun)
      return;
    hasRun = true;
    return cb(...params2);
  };
  return (
    /** @type {CB} */
    wrapper
  );
};

// node_modules/hookar/esm/index.mjs
var createHooksCollection = (runner) => {
  const hooks = [];
  const hooksCollection = (hook) => {
    hooks.push(hook);
    return () => hooks.splice(hooks.indexOf(hook), 1);
  };
  hooksCollection.hooks = hooks;
  hooksCollection.run = runner(hooks);
  hooksCollection.runOnce = runOnce(runner(hooks));
  return hooksCollection;
};
var createPipelineCollection = (type) => (
  // @ts-ignore
  createHooksCollection(
    (hooks) => (value, ...rest) => hooks.reduce(
      (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => hook(r, ...rest)) : hook(pipedValue, ...rest),
      value
    )
  )
);
var createSequenceHooksCollection = (type) => createHooksCollection(
  (hooks) => (value, ...rest) => hooks.reduce(
    (last, hook) => (last == null ? void 0 : last.then) ? last.then((_) => hook(value, ...rest)) : hook(value, ...rest),
    value
  )
);
var createGuardsCollection = (type) => (
  // @ts-ignore
  createHooksCollection(
    (hooks) => (value, ...rest) => hooks.reduce(
      (pipedValue, hook) => (pipedValue == null ? void 0 : pipedValue.then) ? pipedValue.then((r) => r && hook(value, ...rest)) : pipedValue && hook(value, ...rest),
      value || true
    )
  )
);

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Address.js
var AddressReflector = class extends BaseReflector {
  /** @param {Router} router */
  constructor(router) {
    super(router);
    __publicField(this, "reflect", () => {
      const { mode } = get_store_value(this.router.activeRoute);
      if (mode === "popState")
        return false;
      const { routers, browserAdapter } = this.router.instance.global;
      const addressRouters = routers.filter(
        (router) => router.urlReflector instanceof this.constructor
      );
      const url2 = browserAdapter.toBrowser(addressRouters);
      this.log.debug("pushing internal url to browser history", {
        mode,
        url: url2,
        currentBrowserUrl: urlFromAddress(),
        currentInternalUrl: this.router.url.internal()
      });
      history[`${mode}Native`]({}, "", url2);
    });
    const { instance: instance8, urlRewrites } = router;
    const { urlFromBrowser, browserAdapter } = instance8.global;
    if (!history["onPushstate"]) {
      this.log.debug("polyfill history hooks");
      polyfillHistory();
    }
    const createStateEventHandler = (method) => {
      return function(data, title, url2) {
        var _a;
        const routerName = ((_a = data == null ? void 0 : data.routify) == null ? void 0 : _a.router) ?? false;
        if (routerName === false)
          url2 = browserAdapter.toRouter(url2, router);
        else if (routerName !== router.name)
          return false;
        for (const rewrite of urlRewrites)
          url2 = rewrite.toInternal(url2, { router });
        router.url[method](url2);
      };
    };
    this.absorb = () => router.url.replace(urlFromBrowser(router));
    this._pushstateHandler = createStateEventHandler("push");
    this._replacestateHandler = createStateEventHandler("replace");
    this._popstateHandler = () => router.url.pop(urlFromBrowser(router));
  }
  install() {
    this.hooks = [
      history["onPushstate"](this._pushstateHandler),
      history["onReplacestate"](this._replacestateHandler),
      history["onPopstate"](this._popstateHandler)
    ];
    if (!get_store_value(this.router.activeRoute))
      this.absorb();
    else
      this.reflect();
  }
  uninstall() {
    this.hooks.forEach((unreg) => unreg());
    setTimeout(() => this.reflect());
  }
};
function polyfillHistory() {
  const hooks = {
    /** @type {import('hookar').HooksCollection<History['pushState']>} */
    onPushstate: createSequenceHooksCollection(),
    /** @type {import('hookar').HooksCollection<History['replaceState']>} */
    onReplacestate: createSequenceHooksCollection(),
    onPopstate: createSequenceHooksCollection()
  };
  Object.assign(history, hooks);
  const { pushState, replaceState } = history;
  history["pushStateNative"] = pushState;
  history["replaceStateNative"] = replaceState;
  history.pushState = hooks.onPushstate.run;
  history.replaceState = hooks.onReplacestate.run;
  window.addEventListener("popstate", hooks.onPopstate.run);
  return true;
}

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/Internal.js
var InternalReflector = class extends BaseReflector {
  install() {
    this.router.url.replace("/");
  }
};

// node_modules/@roxi/routify/lib/runtime/plugins/reset/index.js
var parseModuleName = (str) => {
  const matches = str.match(/^(.+?)(\+)?$/);
  const [, name, prepend] = matches;
  return { name, prepend };
};
var createHandlers = (fragments, route) => {
  const getIndexOf = (fragment) => fragments.indexOf(fragment);
  const handlers = {
    /**
     * @param {Boolean} _bool
     * @param {RouteFragment} fragment
     */
    boolean(_bool, fragment) {
      const index = getIndexOf(fragment);
      return handlers.number(index, fragment);
    },
    /**
     * @param {Number} num
     * @param {RouteFragment} fragment
     */
    number(num, fragment) {
      const index = fragments.indexOf(fragment);
      const start = index - num;
      fragments.splice(start, num);
    },
    /**
     * @param {string} str
     * @param {RouteFragment} fragment
     */
    string(str, fragment) {
      const selfIndex = getIndexOf(fragment);
      const precedingFragments = fragments.slice(0, selfIndex + 1);
      let nextFragment;
      const { name, prepend } = parseModuleName(str);
      while (precedingFragments.length) {
        nextFragment = precedingFragments.pop();
        const matchingSiblingNode = nextFragment.node.children.find(
          (node2) => node2.meta.moduleName === name
        );
        if (matchingSiblingNode) {
          if (!prepend)
            fragments.splice(0, getIndexOf(fragment));
          fragments.unshift(route.createFragment(matchingSiblingNode));
          precedingFragments.splice(0);
        }
      }
    }
  };
  return handlers;
};
var handleFragment = (handlers) => (fragment) => {
  const { reset } = fragment.node.meta;
  if (reset)
    handlers[typeof reset](reset, fragment);
};
var reset_default = () => ({
  transformFragments: (_fragments) => {
    const { route } = _fragments[0];
    const fragments = [..._fragments];
    const handlers = createHandlers(fragments, route);
    _fragments.forEach(handleFragment(handlers));
    return fragments;
  }
});

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/utils.js
function findNextScrollableAncestor(element2, boundaryElements = []) {
  const isScrollable = (elem) => elem.scrollWidth > elem.clientWidth || elem.scrollHeight > elem.clientHeight;
  if (element2.parentElement && !boundaryElements.includes(element2) && !element2.dataset.hasOwnProperty("routifyScrollLock")) {
    if (isScrollable(element2.parentElement) || element2.parentElement === document.documentElement) {
      return element2.parentElement;
    } else {
      return findNextScrollableAncestor(element2.parentElement, boundaryElements);
    }
  } else {
    return null;
  }
}
function waitForScrollToComplete(elem) {
  let counter = 0;
  let lastPos = null;
  return new Promise((resolve) => {
    requestAnimationFrame(checkPos);
    function checkPos() {
      const { top, left } = elem.getBoundingClientRect();
      const newPos = top + "/" + left;
      counter++;
      if (newPos === lastPos && counter > 2) {
        resolve();
      } else {
        lastPos = newPos;
        requestAnimationFrame(checkPos);
      }
    }
  });
}
var observeDocument = (callback, runOnInit, timeout) => {
  if (runOnInit)
    callback();
  new ResizeObserver(() => {
  });
  const observer = new MutationObserver((mutations) => {
    const mutationsHasAddedOrRemovedANode = mutations.some(
      (mutation) => mutation.type === "childList" || mutation.type === "characterData"
    );
    if (mutationsHasAddedOrRemovedANode)
      callback();
  });
  observer.observe(document.body, {
    childList: true,
    subtree: true,
    characterData: true
  });
  if (timeout)
    setTimeout(() => observer.disconnect(), timeout);
  return observer;
};
var backupScrollBehavior = (elem) => {
  elem.oldBehavior = elem.oldBehavior || elem.style.scrollBehavior;
};
var restoreScrollBehavior = (elem) => {
  if (elem.oldBehavior)
    elem.style.scrollBehavior = elem.oldBehavior;
  else
    elem.style.removeProperty("scroll-behavior");
  delete elem.oldBehavior;
};
var getAllAncestors = (elem) => {
  const ancestors = [];
  let parent = elem.parentElement;
  while (parent) {
    ancestors.push(parent);
    parent = parent.parentElement;
  }
  return ancestors;
};

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/ScrollContext.js
var ScrollContext = class {
  /**
   * @param {RenderContext} context
   */
  constructor(context2) {
    /** @type {HTMLElement} */
    __publicField(this, "elem");
    /** @type {RenderContext} */
    __publicField(this, "ctx");
    /** @type {boolean} */
    __publicField(this, "isInstant");
    /** @type {HTMLElement} */
    __publicField(this, "scrollTarget");
    this.ctx = context2;
  }
  async getBoundary() {
    return resolveIfAnonFn(this.ctx.scrollBoundary, [this.ctx, this.scrollTarget]);
  }
  async init() {
    var _a, _b, _c, _d, _e;
    const { ctx } = this;
    const { anchor, parent } = await waitFor(ctx.elem, Boolean);
    this.scrollTarget = anchor || parent;
    const hashElem = ((_a = ctx.route) == null ? void 0 : _a.hash) && ((_c = globalThis.document) == null ? void 0 : _c.getElementById((_b = ctx.route) == null ? void 0 : _b.hash));
    this.elem = hashElem || this.scrollTarget;
    this.scrollToElem = ctx.isInline || ((_d = ctx.route) == null ? void 0 : _d.hash);
    this.isInstant = ((_e = ctx.route) == null ? void 0 : _e.state.dontsmoothscroll) || !ctx.wasVisible;
  }
  async handleScrollInstructions() {
    const { elem, isInstant, ctx } = this;
    const { scrollIntoView } = ctx.inline;
    const ancestors = getAllAncestors(elem);
    ancestors.forEach(backupScrollBehavior);
    if (isInstant)
      ancestors.forEach((ancestor) => ancestor.style.scrollBehavior = "auto");
    const observer = observeDocument(() => scrollIntoView(elem, isInstant), true);
    const timeout = isInstant ? 300 : 0;
    setTimeout(() => {
      observer.disconnect();
      ancestors.forEach(restoreScrollBehavior);
    }, timeout);
    return waitForScrollToComplete(elem);
  }
};

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/ScrollQueue.js
var defaultShouldScrollCallback = (_scrollContext, index, ScrollContexts) => index === ScrollContexts.length - 1;
var ScrollQueue = class {
  constructor() {
    /** @type {ScrollContext[]} */
    __publicField(this, "queue", []);
  }
  /**
   * Adds an element to the queue with its respective callback function.
   * @param {ScrollContext} scrollContext
   */
  push(scrollContext) {
    var _a;
    if (scrollContext.ctx.route != ((_a = this.queue[0]) == null ? void 0 : _a.ctx.route))
      this.queue = [];
    this.queue.push(scrollContext);
  }
  /**
   * Processes the queue of elements and callbacks to execute them sequentially.
   * @return {Promise<void>} A promise that resolves when the entire queue has been processed.
   */
  async processQueue() {
    this.queue = this.queue.filter(
      (scrollContext, index, arr) => scrollContext.ctx.inline.shouldScroll(
        scrollContext,
        index,
        arr,
        defaultShouldScrollCallback
      )
    );
    while (this.queue.length) {
      const scrollContext = this.queue.shift();
      await scrollContext.handleScrollInstructions();
    }
  }
};
var scrollQueue = new ScrollQueue();

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/scroll.js
var scrollToContext = async (context2) => {
  const scrollContext = new ScrollContext(context2);
  await scrollContext.init();
  if (!scrollContext.elem)
    ;
  else if (scrollContext.scrollToElem) {
    scrollQueue.push(scrollContext);
  } else
    scrollToTop(scrollContext.elem, await scrollContext.getBoundary());
};
var scrollToTop = (elem, boundary) => {
  let parent = findNextScrollableAncestor(elem, [boundary]);
  while (parent) {
    const oldBehavior = parent.style.scrollBehavior;
    parent.style.scrollBehavior = "auto";
    parent.scrollTo(0, 0);
    parent.style.scrollBehavior = oldBehavior;
    parent = findNextScrollableAncestor(parent, [boundary]);
  }
};

// node_modules/@roxi/routify/lib/runtime/renderer/utils/index.js
var getLineage = (context2) => {
  const contexts2 = [];
  while (context2) {
    contexts2.push(context2);
    context2 = context2.parentContext;
  }
  return contexts2;
};

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/ScrollDecorator.svelte
function create_fragment2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[4],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[4],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[4]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[4],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let route;
  let router;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ScrollDecorator", slots, ["default"]);
  let { context: context2 } = $$props;
  let { isRoot } = $$props;
  isRoot;
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<ScrollDecorator> was created without expected prop 'context'");
    }
    if (isRoot === void 0 && !("isRoot" in $$props || $$self.$$.bound[$$self.$$.props["isRoot"]])) {
      console.warn("<ScrollDecorator> was created without expected prop 'isRoot'");
    }
  });
  const writable_props = ["context", "isRoot"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ScrollDecorator> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("isRoot" in $$props2)
      $$invalidate(1, isRoot = $$props2.isRoot);
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    get: get_store_value,
    scrollToContext,
    getLineage,
    context: context2,
    isRoot,
    router,
    route
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("isRoot" in $$props2)
      $$invalidate(1, isRoot = $$props2.isRoot);
    if ("router" in $$props2)
      $$invalidate(2, router = $$props2.router);
    if ("route" in $$props2)
      $$invalidate(3, route = $$props2.route);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a;
    if ($$self.$$.dirty & /*context*/
    1) {
      $:
        $$invalidate(3, { route, router } = context2, route, ($$invalidate(2, router), $$invalidate(0, context2)));
    }
    if ($$self.$$.dirty & /*route, context, router*/
    13) {
      $:
        if (route && !route.state.dontScroll) {
          if (route.hash && route.leaf === context2.fragment) {
            scrollToContext(context2);
          } else if (
            // The node is the leaf of the active route of the router.
            (get_store_value(router.activeRoute).leaf.node === context2.node || // the node and its ancestors are all active
            getLineage(context2).every((ctx) => get_store_value(ctx.isActive))) && // don't scroll if the node context was already active
            context2 !== ((_a = context2.parentContext) == null ? void 0 : _a.lastActiveChildContext)
          )
            scrollToContext(context2);
        }
    }
  };
  return [context2, isRoot, router, route, $$scope, slots];
}
var ScrollDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { context: 0, isRoot: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScrollDecorator",
      options,
      id: create_fragment2.name
    });
  }
  get context() {
    throw new Error("<ScrollDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ScrollDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isRoot() {
    throw new Error("<ScrollDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isRoot(value) {
    throw new Error("<ScrollDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ScrollDecorator_default = ScrollDecorator;

// node_modules/@roxi/routify/lib/runtime/plugins/scroller/plugin.js
var plugin_default = () => ({
  onMount: ({ context: context2 }) => {
    context2.decorators.push(ScrollDecorator_default);
  },
  afterRouteRendered: () => scrollQueue.processQueue()
});

// node_modules/@roxi/routify/lib/common/utils.js
var next = (store, wanted, strict) => new Promise((resolve) => {
  let unsub;
  unsub = store.subscribe((value) => {
    if (!unsub)
      return;
    if (typeof wanted === "undefined" || value === wanted || value == wanted && !strict || typeof wanted === "function" && /** @type {function} */
    wanted(value)) {
      resolve(value);
      unsub;
    }
  });
});
var createThrottle = () => {
  const map = /* @__PURE__ */ new Map();
  const throttle2 = async (fn) => {
    const fnStr = fn.toString();
    map.set(fnStr, map.get(fnStr) || { isRunning: false, runAgain: false });
    const s = map.get(fnStr);
    if (s.isRunning)
      s.runAgain = true;
    else {
      s.isRunning = true;
      await fn();
      s.isRunning = false;
      if (s.runAgain) {
        s.runAgain = false;
        await throttle2(fn);
      }
    }
  };
  return throttle2;
};
var throttle = createThrottle();
var lazySet = (store, value) => JSON.stringify(get_store_value(store)) !== JSON.stringify(value) && store.set(value);
var jsonClone = (obj) => JSON.parse(JSON.stringify(obj));

// node_modules/@roxi/routify/lib/runtime/Router/utils/index.js
var normalizeRouterOptions = (options, config) => {
  config = config || {
    name: "",
    beforeRouterInit: [],
    afterRouterInit: [],
    urlRewrite: [],
    beforeUrlChange: [],
    afterUrlChange: [],
    afterRouteRendered: [],
    transformFragments: [],
    onMount: [],
    onDestroy: []
  };
  const { plugins, ...optionsOnly } = options;
  const optionsGroups = [...plugins || [], optionsOnly];
  optionsGroups.forEach((pluginOptions) => {
    var _a;
    (_a = pluginOptions.plugins) == null ? void 0 : _a.forEach((plugin) => normalizeRouterOptions(plugin, config));
    delete pluginOptions.plugins;
    Object.entries(pluginOptions).forEach(([field, value]) => {
      if (Array.isArray(config[field]))
        config[field].push(...[value].flat().filter(Boolean));
      else
        config[field] = value || config[field];
    });
  });
  return config;
};

// node_modules/@roxi/routify/lib/runtime/Router/Router.js
var stripNullFields = (obj) => Object.fromEntries(Object.entries(obj).filter(([_, v]) => v != null));
var defaultPlugins = [reset_default(), plugin_default()];
var Router = class _Router {
  /**
   * @param {Partial<RoutifyRuntimeOptions>} input
   */
  constructor(input) {
    /** @type { RouteStore } */
    __publicField(this, "pendingRoute", getable(null));
    /** @type { RouteStore } */
    __publicField(this, "activeRoute", getable(null));
    __publicField(this, "_urlReflector", null);
    /** @type {UrlRewrite[]} */
    __publicField(this, "urlRewrites", []);
    /** @type { import('hookar').HooksCollection<RouterInitCallback> } */
    __publicField(this, "beforeRouterInit", createSequenceHooksCollection());
    /** @type { import('hookar').HooksCollection<RouterInitCallback> } */
    __publicField(this, "afterRouterInit", createSequenceHooksCollection());
    /** @type { import('hookar').HooksCollection<BeforeUrlChangeCallback> } */
    __publicField(this, "beforeUrlChange", createGuardsCollection());
    /** @type { import('hookar').HooksCollection<AfterUrlChangeCallback> } */
    __publicField(this, "afterUrlChange", createSequenceHooksCollection());
    /** @type { import('hookar').HooksCollection<AfterRouteRenderedCallback> } */
    __publicField(this, "afterRouteRendered", createSequenceHooksCollection());
    /** @type { import('hookar').HooksCollection<TransformFragmentsCallback> } */
    __publicField(this, "transformFragments", createPipelineCollection());
    __publicField(this, "onMount", createSequenceHooksCollection());
    /** @type { import('hookar').HooksCollection<OnDestroyRouterCallback> } */
    __publicField(this, "onDestroy", createSequenceHooksCollection());
    __publicField(this, "parentElem", null);
    /** @type {QueryHandler} */
    __publicField(this, "queryHandler", {
      parse: (search, route) => fromEntries(new URLSearchParams(search)),
      stringify: (params2, route) => {
        const query = new URLSearchParams(params2).toString();
        return query ? `?${query}` : "";
      }
    });
    /** @type {ClickHandler} */
    __publicField(this, "clickHandler", {});
    __publicField(this, "url", {
      internal: () => this.url.getPending() || this.url.getActive(),
      external: () => this.getExternalUrl(),
      getActive: () => {
        var _a;
        return (_a = get_store_value(this.activeRoute)) == null ? void 0 : _a.url;
      },
      getPending: () => {
        var _a;
        return (_a = get_store_value(this.pendingRoute)) == null ? void 0 : _a.url;
      },
      toString: () => this.url.internal(),
      set: this._setUrl.bind(this),
      push: (url2, state = {}) => this._setUrl(url2, "pushState", false, state),
      replace: (url2, state = {}) => this._setUrl(url2, "replaceState", false, state),
      pop: (url2, state = {}) => this._setUrl(url2, "popState", false, state)
    });
    /**
     * function that resolves after the active route has changed
     * @returns {Promise<Route>} */
    __publicField(this, "ready", async () => !this.pendingRoute.get() && this.activeRoute.get() || next(this.activeRoute, (x) => !!x));
    /** @type {Route[]} */
    __publicField(this, "history", []);
    /** @param {HTMLElement} elem */
    __publicField(this, "setParentElem", (elem) => {
      this.parentElem = elem;
    });
    /**
     * converts a URL or Routify's internal URL to an external URL (for the browser)
     * @param {string=} url
     * @returns
     */
    __publicField(this, "getExternalUrl", (url2) => {
      const result = this.urlRewrites.reduce(
        (_url2, rewrite) => rewrite.toExternal(_url2, { router: this }),
        url2 || this.url.internal() || ""
      );
      return result;
    });
    /**
     * converts an external URL (from the browser) to an internal URL
     * @param {string} url
     * @returns
     */
    __publicField(this, "getInternalUrl", (url2) => this.urlRewrites.reduce(
      (_url2, rewrite) => rewrite.toInternal(_url2, { router: this }),
      url2
    ));
    const matchingRouter = appInstance.routers.find((r) => r.name == (input.name || ""));
    if (matchingRouter) {
      matchingRouter.init(input);
      return matchingRouter;
    }
    this.parentCmpCtx = getRoutifyFragmentContextMaybe();
    const { subscribe: subscribe2, set } = writable(this);
    this.subscribe = subscribe2;
    this.triggerStore = () => set(this);
    this.init(input);
    this.params = derived(this.activeRoute, ($activeRoute) => $activeRoute.params);
    this.afterUrlChange(() => setTimeout(() => this._urlReflector.reflect()));
    this.activeRoute.get = () => get_store_value(this.activeRoute);
    this.pendingRoute.get = () => get_store_value(this.pendingRoute);
  }
  /**
   * @param {Partial<RoutifyRuntimeOptions>} input
   */
  init(input) {
    var _a, _b;
    const firstInit = !this.options;
    input.plugins = [...defaultPlugins, ...input.plugins || []].filter(Boolean);
    input = stripNullFields(input);
    this.options = normalizeRouterOptions({ ...this.options, ...input });
    let {
      instance: instance8,
      rootNode,
      name,
      routes,
      urlRewrite,
      urlReflector,
      url: url2,
      passthrough,
      beforeUrlChange: beforeUrlChange2,
      afterUrlChange: afterUrlChange2,
      afterRouteRendered,
      transformFragments,
      onMount: onMount2,
      onDestroy: onDestroy2,
      beforeRouterInit,
      afterRouterInit,
      queryHandler,
      clickHandler
    } = this.options;
    if (queryHandler)
      this.queryHandler = queryHandler;
    if (clickHandler)
      this.clickHandler = clickHandler;
    beforeUrlChange2.forEach(this.beforeUrlChange);
    transformFragments.forEach(this.transformFragments);
    afterUrlChange2.forEach(this.afterUrlChange);
    afterRouteRendered.forEach(this.afterRouteRendered);
    onMount2.forEach(this.onMount);
    onDestroy2.forEach(this.onDestroy);
    beforeRouterInit.forEach(this.beforeRouterInit);
    afterRouterInit.forEach(this.afterRouterInit);
    this.beforeRouterInit.run({ router: this, firstInit });
    this.instance = instance8 || this.instance || ((_a = this.parentCmpCtx) == null ? void 0 : _a.route.router.instance) || appInstance.instances[0] || new RoutifyRuntime({});
    this.name = name ?? this.name;
    this.urlRewrites = urlRewrite ?? this.urlRewrites;
    this.log = this.log || this.instance.log.createChild(this.name || "[unnamed instance]");
    if (passthrough && !(passthrough instanceof _Router))
      passthrough = ((_b = this.parentCmpCtx) == null ? void 0 : _b.route.router) || passthrough;
    this.passthrough = passthrough || this.passthrough;
    appInstance.instances.forEach((inst) => {
      const index = inst.routers.indexOf(this);
      if (index !== -1)
        inst.routers.splice(index, 1);
    });
    this.instance.routers.push(this);
    if (routes && !this.rootNode)
      this.importRoutes(routes);
    this.rootNode = rootNode ?? this.rootNode ?? this.instance.rootNodes[this.name || "default"];
    this.log.debug("initiated router");
    if (this.url.getActive()) {
      this.log.debug("router was created with activeUrl");
      this._setUrl(this.url.getActive(), "pushState", true);
    }
    const shouldInstallUrlReflector = !this.urlReflector || urlReflector && !(this.urlReflector instanceof urlReflector);
    if (shouldInstallUrlReflector) {
      urlReflector = urlReflector || (typeof window != "undefined" ? AddressReflector : InternalReflector);
      this.setUrlReflector(urlReflector);
    }
    if (url2)
      this.url.replace(url2);
    this.triggerStore();
    this.afterRouterInit.run({ router: this, firstInit });
  }
  importRoutes(routes) {
    this.rootNode = this.instance.createNode().importTree(routes);
    this.instance.rootNodes[routes.rootName || "unnamed"] = this.rootNode;
  }
  /**
   *
   * @param {string} url
   * @param {UrlState} mode pushState, replaceState or popState
   * @param {boolean} [isInternal=false] if the URL is already internal, skip rewrite.toInternal
   * @param {Object=} state a state to attach to the route
   * @returns {Promise<true|false>}
   */
  async _setUrl(url2, mode, isInternal, state = {}) {
    if (!isInternal)
      url2 = this.getInternalUrl(url2);
    url2 = url2 || "/";
    url2 = url2.replace(/(.+)\/+([#?]|$)/, "$1$2");
    const { debug, groupCollapsed, trace, groupEnd } = this.log;
    if (this.log.level >= 4) {
      const info = {
        url: url2,
        mode,
        prev: this.url.internal(),
        browserOld: urlFromAddress(),
        state
      };
      [groupCollapsed("set url", info), trace(), groupEnd()];
    }
    if (!url2.startsWith("/"))
      url2 = url2.startsWith("http") ? url2.replace(new URL(url2).origin, "") : `/${url2}`;
    const currentRoute = this.pendingRoute.get() || this.activeRoute.get();
    if (!this.rootNode && this.instance.global.routeMaps[this.name])
      this.importRoutes(await this.instance.global.routeMaps[this.name]());
    const route = new Route(this, url2, mode, state);
    const loadRoutePromise = route.loadRoute();
    if (state.prefetch)
      return;
    if (identicalRoutes(currentRoute, route)) {
      debug("current route is identical - skip", currentRoute, route);
      return false;
    } else {
      route.log.debug("set pending route", route);
      this.pendingRoute.set(route);
      const didLoadRoute = await loadRoutePromise;
      if (this.pendingRoute.get() === route)
        this.pendingRoute.set(null);
      if (didLoadRoute)
        this.setActiveRoute(route);
      await new Promise((resolve) => setTimeout(resolve));
      return true;
    }
  }
  setActiveRoute(route) {
    this.log.debug("set active route", this);
    const $activeRoute = this.activeRoute.get();
    if ($activeRoute)
      this.history.push($activeRoute);
    this.activeRoute.set(route);
    this.afterUrlChange.run({
      route,
      history: [...this.history].reverse()
    });
    Promise.all(
      route.fragments.map(
        (fragment) => fragment.renderContext.then((rc) => rc.mounted)
      )
    ).then(() => this.afterRouteRendered.run({ route }));
    this.log.debug("unset pending route", this);
  }
  destroy() {
    this.log.debug(`destroying router`);
    this.instance.routers = this.instance.routers.filter((router) => router !== this);
    this.onDestroy.run({ router: this });
  }
  /** @type {BaseReflector} */
  get urlReflector() {
    return this._urlReflector;
  }
  /** @param {typeof BaseReflector} UrlReflector */
  setUrlReflector(UrlReflector) {
    var _a;
    (_a = this._urlReflector) == null ? void 0 : _a.uninstall();
    this._urlReflector = new UrlReflector(this);
    this._urlReflector.install();
    this.triggerStore();
  }
};
var createRouter = (options) => new Router(options);

// node_modules/@roxi/routify/lib/runtime/renderer/DecoratorWrapper.svelte
function create_else_block2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(23:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = (
    /*decorator*/
    ctx[2].component
  );
  function switch_props(ctx2, dirty) {
    return {
      props: {
        context: (
          /*context*/
          ctx2[1]
        ),
        isRoot: (
          /*isRoot*/
          ctx2[0]
        ),
        $$slots: { default: [create_default_slot2] },
        $$scope: { ctx: ctx2 }
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*decorator*/
      4 && switch_value !== (switch_value = /*decorator*/
      ctx2[2].component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*context*/
        2)
          switch_instance_changes.context = /*context*/
          ctx2[1];
        if (dirty & /*isRoot*/
        1)
          switch_instance_changes.isRoot = /*isRoot*/
          ctx2[0];
        if (dirty & /*$$scope, restOfDecorators, context*/
        74) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(17:0) {#if decorator}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[5].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(19:8) <svelte:self decorators={restOfDecorators} {context} isRoot={false}>",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let decoratorwrapper;
  let current;
  decoratorwrapper = new DecoratorWrapper({
    props: {
      decorators: (
        /*restOfDecorators*/
        ctx[3]
      ),
      context: (
        /*context*/
        ctx[1]
      ),
      isRoot: false,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(decoratorwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(decoratorwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(decoratorwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const decoratorwrapper_changes = {};
      if (dirty & /*restOfDecorators*/
      8)
        decoratorwrapper_changes.decorators = /*restOfDecorators*/
        ctx2[3];
      if (dirty & /*context*/
      2)
        decoratorwrapper_changes.context = /*context*/
        ctx2[1];
      if (dirty & /*$$scope*/
      64) {
        decoratorwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      decoratorwrapper.$set(decoratorwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(decoratorwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(decoratorwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(decoratorwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(18:4) <svelte:component this={decorator.component} {context} {isRoot}>",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*decorator*/
      ctx2[2]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DecoratorWrapper", slots, ["default"]);
  let { decorators = null } = $$props;
  let { isRoot = true } = $$props;
  let { context: context2 } = $$props;
  decorators = decorators || context2.decorators;
  let [decorator, ...restOfDecorators] = [...decorators];
  while (decorator && !(decorator == null ? void 0 : decorator.shouldRender({ context: context2, isRoot, decorators })))
    [decorator, ...restOfDecorators] = [...restOfDecorators];
  if (isRoot)
    onDestroy(() => context2.onDestroy.run());
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<DecoratorWrapper> was created without expected prop 'context'");
    }
  });
  const writable_props = ["decorators", "isRoot", "context"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DecoratorWrapper> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(4, decorators = $$props2.decorators);
    if ("isRoot" in $$props2)
      $$invalidate(0, isRoot = $$props2.isRoot);
    if ("context" in $$props2)
      $$invalidate(1, context2 = $$props2.context);
    if ("$$scope" in $$props2)
      $$invalidate(6, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    onDestroy,
    decorators,
    isRoot,
    context: context2,
    decorator,
    restOfDecorators
  });
  $$self.$inject_state = ($$props2) => {
    if ("decorators" in $$props2)
      $$invalidate(4, decorators = $$props2.decorators);
    if ("isRoot" in $$props2)
      $$invalidate(0, isRoot = $$props2.isRoot);
    if ("context" in $$props2)
      $$invalidate(1, context2 = $$props2.context);
    if ("decorator" in $$props2)
      $$invalidate(2, decorator = $$props2.decorator);
    if ("restOfDecorators" in $$props2)
      $$invalidate(3, restOfDecorators = $$props2.restOfDecorators);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isRoot, context2, decorator, restOfDecorators, decorators, slots, $$scope];
}
var DecoratorWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { decorators: 4, isRoot: 0, context: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DecoratorWrapper",
      options,
      id: create_fragment3.name
    });
  }
  get decorators() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorators(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isRoot() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isRoot(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error("<DecoratorWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<DecoratorWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DecoratorWrapper_default = DecoratorWrapper;

// node_modules/@roxi/routify/lib/runtime/decorators/Noop.svelte
function create_fragment4(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Noop", slots, ["default"]);
  let { context: context2 = null } = $$props;
  let { Parent = null } = $$props;
  context2;
  Parent;
  const writable_props = ["context", "Parent"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Noop> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ context: context2, Parent });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("Parent" in $$props2)
      $$invalidate(1, Parent = $$props2.Parent);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [context2, Parent, $$scope, slots];
}
var Noop = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { context: 0, Parent: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Noop",
      options,
      id: create_fragment4.name
    });
  }
  get context() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Parent() {
    throw new Error("<Noop>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Parent(value) {
    throw new Error("<Noop>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Noop_default = Noop;

// node_modules/@roxi/routify/lib/runtime/decorators/AnchorDecorator.svelte
var { Error: Error_1, console: console_1 } = globals;
var file = "node_modules\\@roxi\\routify\\lib\\runtime\\decorators\\AnchorDecorator.svelte";
function create_else_block3(ctx) {
  let t0;
  let t1;
  let if_block1_anchor;
  let current;
  let if_block0 = !/*mounted*/
  ctx[2] && create_if_block_3(ctx);
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let if_block1 = !/*mounted*/
  ctx[2] && create_if_block_2(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t0 = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*mounted*/
      ctx2[2]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!/*mounted*/
      ctx2[2]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block3.name,
    type: "else",
    source: "(53:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div;
  let t;
  let current;
  let div_levels = [
    { "data-routify-anchor-header": "" },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      t = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-routify-anchor-header": true });
      children(div).forEach(detach_dev);
      t = claim_space(nodes);
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 50, 4, 1640);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[9](div);
      insert_hydration_dev(target, t, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "data-routify-anchor-header": "" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
        detach_dev(t);
      }
      ctx[9](null);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(50:32) ",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[7].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[6],
    null
  );
  let div_levels = [
    { "data-routify-anchor-parent": "" },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { "data-routify-anchor-parent": true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 46, 4, 1508);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[8](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[6],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[6]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[6],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "data-routify-anchor-parent": "" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[8](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(46:0) {#if location === 'wrapper'}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div;
  let div_levels = [
    { "data-routify-anchor-locator": "" },
    { class: "anchor" },
    /*$$restProps*/
    ctx[3]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        "data-routify-anchor-locator": true,
        class: true
      });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 54, 8, 1757);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[10](div);
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        { "data-routify-anchor-locator": "" },
        { class: "anchor" },
        dirty & /*$$restProps*/
        8 && /*$$restProps*/
        ctx2[3]
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[10](null);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(54:4) {#if !mounted}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "data-routify-anchor-backstop": true
      });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "anchor-backstop");
      attr_dev(div, "data-routify-anchor-backstop", "");
      add_location(div, file, 62, 19, 1933);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(63:4) {#if !mounted}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block3, create_if_block_1, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*location*/
      ctx2[0] === "wrapper"
    )
      return 0;
    if (
      /*location*/
      ctx2[0] === "header"
    )
      return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["location", "onMount", "context"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AnchorDecorator", slots, ["default"]);
  let { location: location2 } = $$props;
  let { onMount: onMount2 = (x) => x } = $$props;
  let { context: context2 } = $$props;
  context2;
  let elem;
  let mounted = false;
  const nextValidSibling = (elem2) => {
    const next2 = (
      /** @type {HTMLElement}*/
      elem2.nextElementSibling
    );
    if ("routifyAnchorBackstop" in next2.dataset) {
      console.warn("found no children in", elem2.parentElement);
      throw new Error("AnchorLocation is set to firstChild, but no children were found");
    }
    return next2 && "routifyAnchorLocator" in next2.dataset ? nextValidSibling(next2) : next2;
  };
  onMount(async () => {
    if (mounted)
      return;
    if (location2 === "wrapper")
      onMount2(elem);
    else if (location2 === "parent")
      onMount2(elem.parentElement);
    else if (location2 === "header")
      onMount2(elem.parentElement, elem);
    else if (location2 === "firstChild") {
      const nextSib = nextValidSibling(elem);
      onMount2(elem.parentElement, nextSib);
    } else
      throw new Error(`Incorrect location provided. Got ${location2}`);
    $$invalidate(2, mounted = true);
  });
  $$self.$$.on_mount.push(function() {
    if (location2 === void 0 && !("location" in $$props || $$self.$$.bound[$$self.$$.props["location"]])) {
      console_1.warn("<AnchorDecorator> was created without expected prop 'location'");
    }
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console_1.warn("<AnchorDecorator> was created without expected prop 'context'");
    }
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  function div_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elem = $$value;
      $$invalidate(1, elem);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("location" in $$new_props)
      $$invalidate(0, location2 = $$new_props.location);
    if ("onMount" in $$new_props)
      $$invalidate(4, onMount2 = $$new_props.onMount);
    if ("context" in $$new_props)
      $$invalidate(5, context2 = $$new_props.context);
    if ("$$scope" in $$new_props)
      $$invalidate(6, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _onMount: onMount,
    location: location2,
    onMount: onMount2,
    context: context2,
    elem,
    mounted,
    nextValidSibling
  });
  $$self.$inject_state = ($$new_props) => {
    if ("location" in $$props)
      $$invalidate(0, location2 = $$new_props.location);
    if ("onMount" in $$props)
      $$invalidate(4, onMount2 = $$new_props.onMount);
    if ("context" in $$props)
      $$invalidate(5, context2 = $$new_props.context);
    if ("elem" in $$props)
      $$invalidate(1, elem = $$new_props.elem);
    if ("mounted" in $$props)
      $$invalidate(2, mounted = $$new_props.mounted);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    location2,
    elem,
    mounted,
    $$restProps,
    onMount2,
    context2,
    $$scope,
    slots,
    div_binding,
    div_binding_1,
    div_binding_2
  ];
}
var AnchorDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { location: 0, onMount: 4, context: 5 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AnchorDecorator",
      options,
      id: create_fragment5.name
    });
  }
  get location() {
    throw new Error_1("<AnchorDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set location(value) {
    throw new Error_1("<AnchorDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onMount() {
    throw new Error_1("<AnchorDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onMount(value) {
    throw new Error_1("<AnchorDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get context() {
    throw new Error_1("<AnchorDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error_1("<AnchorDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AnchorDecorator_default = AnchorDecorator;

// node_modules/@roxi/routify/lib/runtime/renderer/RenderFragment.svelte
var file2 = "node_modules\\@roxi\\routify\\lib\\runtime\\renderer\\RenderFragment.svelte";
function create_if_block4(ctx) {
  let decoratorwrapper;
  let current;
  decoratorwrapper = new DecoratorWrapper_default({
    props: {
      context: (
        /*context*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(decoratorwrapper.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(decoratorwrapper.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(decoratorwrapper, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const decoratorwrapper_changes = {};
      if (dirty & /*context*/
      1)
        decoratorwrapper_changes.context = /*context*/
        ctx2[0];
      if (dirty & /*$$scope, context, NodeComponent, compProps, props, $childFragments, hasInlineChildren*/
      1048695) {
        decoratorwrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      decoratorwrapper.$set(decoratorwrapper_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(decoratorwrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(decoratorwrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(decoratorwrapper, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(50:0) {#if $isVisible && !isAnonFn(NodeComponent)}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let compose;
  let current;
  compose = new ComposeFragments_default({
    props: {
      options: {
        inline: (
          /*inline*/
          ctx[14] || /*multi*/
          ctx[15]
        ),
        decorator: (
          /*decorator*/
          ctx[16]
        ),
        props: (
          /*props*/
          ctx[1]
        ),
        options: (
          /*options*/
          ctx[18]
        ),
        scrollBoundary: (
          /*scrollBoundary*/
          ctx[19]
        ),
        anchor: (
          /*anchor*/
          ctx[17] || /*context*/
          ctx[0].anchorLocation
        )
      },
      context: (
        /*context*/
        ctx[0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(compose.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(compose.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(compose, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const compose_changes = {};
      if (dirty & /*inline, multi, decorator, props, options, scrollBoundary, anchor, context*/
      1032195)
        compose_changes.options = {
          inline: (
            /*inline*/
            ctx2[14] || /*multi*/
            ctx2[15]
          ),
          decorator: (
            /*decorator*/
            ctx2[16]
          ),
          props: (
            /*props*/
            ctx2[1]
          ),
          options: (
            /*options*/
            ctx2[18]
          ),
          scrollBoundary: (
            /*scrollBoundary*/
            ctx2[19]
          ),
          anchor: (
            /*anchor*/
            ctx2[17] || /*context*/
            ctx2[0].anchorLocation
          )
        };
      if (dirty & /*context*/
      1)
        compose_changes.context = /*context*/
        ctx2[0];
      compose.$set(compose_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(compose.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(compose.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(compose, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(68:17) {#if $childFragments.length || ((hasInlineChildren || inline || multi) && !(inline || multi)?.single)}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  var _a;
  let if_block_anchor;
  let current;
  let if_block = (
    /*$childFragments*/
    (ctx[6].length || /*hasInlineChildren*/
    (ctx[5] || /*inline*/
    ctx[14] || /*multi*/
    ctx[15]) && !/*inline*/
    ((_a = ctx[14] || /*multi*/
    ctx[15]) == null ? void 0 : _a.single)) && create_if_block_12(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      var _a2;
      if (
        /*$childFragments*/
        ctx2[6].length || /*hasInlineChildren*/
        (ctx2[5] || /*inline*/
        ctx2[14] || /*multi*/
        ctx2[15]) && !/*inline*/
        ((_a2 = ctx2[14] || /*multi*/
        ctx2[15]) == null ? void 0 : _a2.single)
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$childFragments, hasInlineChildren, inline, multi*/
          49248) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_12(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(57:12) <svelte:component                 this={NodeComponent}                 {...compProps}                 {context}                 let:props                 let:inline                 let:multi                 let:decorator                 let:anchor                 let:options                 let:scrollBoundary                 >",
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let switch_instance;
  let t;
  let div;
  let childMounted_action;
  let current;
  let mounted;
  let dispose;
  const switch_instance_spread_levels = [
    /*compProps*/
    ctx[4],
    { context: (
      /*context*/
      ctx[0]
    ) }
  ];
  var switch_value = (
    /*NodeComponent*/
    ctx[2]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: {
        default: [
          create_default_slot_2,
          ({ props, inline, multi, decorator, anchor, options, scrollBoundary }) => ({
            1: props,
            14: inline,
            15: multi,
            16: decorator,
            17: anchor,
            18: options,
            19: scrollBoundary
          }),
          ({ props, inline, multi, decorator, anchor, options, scrollBoundary }) => (props ? 2 : 0) | (inline ? 16384 : 0) | (multi ? 32768 : 0) | (decorator ? 65536 : 0) | (anchor ? 131072 : 0) | (options ? 262144 : 0) | (scrollBoundary ? 524288 : 0)
        ]
      },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty & /*compProps, context*/
    17) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty & /*compProps*/
        16 && get_spread_object(
          /*compProps*/
          ctx2[4]
        ),
        dirty & /*context*/
        1 && { context: (
          /*context*/
          ctx2[0]
        ) }
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      t = space();
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", {});
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 80, 12, 3366);
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(childMounted_action = /*childMounted*/
        ctx[10].call(null, div));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*NodeComponent*/
      4 && switch_value !== (switch_value = /*NodeComponent*/
      ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, t.parentNode, t);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*compProps, context*/
        17 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*compProps*/
          16 && get_spread_object(
            /*compProps*/
            ctx2[4]
          ),
          dirty & /*context*/
          1 && { context: (
            /*context*/
            ctx2[0]
          ) }
        ]) : {};
        if (dirty & /*$$scope, inline, multi, decorator, props, options, scrollBoundary, anchor, context, $childFragments, hasInlineChildren*/
        2080867) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(div);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: "(55:8) <AnchorDecorator location={context.anchorLocation} onMount={initialize} {context}>",
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let anchordecorator;
  let current;
  anchordecorator = new AnchorDecorator_default({
    props: {
      location: (
        /*context*/
        ctx[0].anchorLocation
      ),
      onMount: (
        /*initialize*/
        ctx[9]
      ),
      context: (
        /*context*/
        ctx[0]
      ),
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(anchordecorator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchordecorator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(anchordecorator, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const anchordecorator_changes = {};
      if (dirty & /*context*/
      1)
        anchordecorator_changes.location = /*context*/
        ctx2[0].anchorLocation;
      if (dirty & /*context*/
      1)
        anchordecorator_changes.context = /*context*/
        ctx2[0];
      if (dirty & /*$$scope, NodeComponent, compProps, context, props, $childFragments, hasInlineChildren*/
      1048695) {
        anchordecorator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchordecorator.$set(anchordecorator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchordecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchordecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchordecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(54:4) <DecoratorWrapper {context}>",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let show_if = (
    /*$isVisible*/
    ctx[3] && !isAnonFn(
      /*NodeComponent*/
      ctx[2]
    )
  );
  let if_block_anchor;
  let current;
  let if_block = show_if && create_if_block4(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$isVisible, NodeComponent*/
      12)
        show_if = /*$isVisible*/
        ctx2[3] && !isAnonFn(
          /*NodeComponent*/
          ctx2[2]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$isVisible, NodeComponent*/
          12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  var _a;
  let hasInlineChildren;
  let params2;
  let load;
  let compProps;
  let $isVisible;
  let $childFragments;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RenderFragment", slots, []);
  let { context: context2 } = $$props;
  let { props } = $$props;
  const { isVisible, childFragments } = context2;
  validate_store(isVisible, "isVisible");
  component_subscribe($$self, isVisible, (value) => $$invalidate(3, $isVisible = value));
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(6, $childFragments = value));
  let NodeComponent = ((_a = context2.node.module) == null ? void 0 : _a.default) || context2.node.asyncModule || Noop_default;
  setRoutifyFragmentContext(context2);
  const updateRenderContext = (elem, newMeta) => {
    var _a2;
    if (elem)
      elem["__routify_meta"] = {
        ...elem && elem["__routify_meta"],
        renderContext: {
          ...(_a2 = elem["__routify_meta"]) == null ? void 0 : _a2.renderContext,
          ...newMeta
        }
      };
    return elem;
  };
  const initialize = async (parent, anchor) => {
    context2.parentContext && await waitFor(context2.parentContext.elem, Boolean);
    context2.elem.set({ anchor, parent });
    parent = updateRenderContext(parent, { parent: context2 });
    if (anchor)
      anchor = updateRenderContext(anchor, { anchor: context2 });
  };
  const childMounted = () => {
    context2.mounted.resolve(context2);
  };
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<RenderFragment> was created without expected prop 'context'");
    }
    if (props === void 0 && !("props" in $$props || $$self.$$.bound[$$self.$$.props["props"]])) {
      console.warn("<RenderFragment> was created without expected prop 'props'");
    }
  });
  const writable_props = ["context", "props"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RenderFragment> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
  };
  $$self.$capture_state = () => ({
    Compose: ComposeFragments_default,
    DecoratorWrapper: DecoratorWrapper_default,
    Noop: Noop_default,
    AnchorDecorator: AnchorDecorator_default,
    isAnonFn,
    setRoutifyFragmentContext,
    waitFor,
    context: context2,
    props,
    isVisible,
    childFragments,
    NodeComponent,
    updateRenderContext,
    initialize,
    childMounted,
    load,
    params: params2,
    compProps,
    hasInlineChildren,
    $isVisible,
    $childFragments
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("NodeComponent" in $$props2)
      $$invalidate(2, NodeComponent = $$props2.NodeComponent);
    if ("load" in $$props2)
      $$invalidate(11, load = $$props2.load);
    if ("params" in $$props2)
      $$invalidate(12, params2 = $$props2.params);
    if ("compProps" in $$props2)
      $$invalidate(4, compProps = $$props2.compProps);
    if ("hasInlineChildren" in $$props2)
      $$invalidate(5, hasInlineChildren = $$props2.hasInlineChildren);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*context*/
    1) {
      $:
        $$invalidate(5, hasInlineChildren = context2.node.children.some((child) => child.meta.inline));
    }
    if ($$self.$$.dirty & /*NodeComponent, $isVisible, context*/
    13) {
      $:
        if (isAnonFn(NodeComponent) && $isVisible)
          context2.node.loadModule().then((r) => $$invalidate(2, NodeComponent = r.default));
    }
    if ($$self.$$.dirty & /*context*/
    1) {
      $:
        $$invalidate(12, { params: params2, load } = context2.fragment, params2, ($$invalidate(11, load), $$invalidate(0, context2)));
    }
    if ($$self.$$.dirty & /*params, load, props*/
    6146) {
      $:
        $$invalidate(4, compProps = { ...params2, ...load == null ? void 0 : load.props, ...props });
    }
  };
  return [
    context2,
    props,
    NodeComponent,
    $isVisible,
    compProps,
    hasInlineChildren,
    $childFragments,
    isVisible,
    childFragments,
    initialize,
    childMounted,
    load,
    params2
  ];
}
var RenderFragment = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { context: 0, props: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RenderFragment",
      options,
      id: create_fragment6.name
    });
  }
  get context() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<RenderFragment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<RenderFragment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RenderFragment_default = RenderFragment;

// node_modules/@roxi/routify/lib/runtime/renderer/utils/normalizeInline.js
var coerceInlineInputToObject = (inlineInput) => {
  if (typeof inlineInput === "undefined")
    return {};
  return {
    // if inline is true, callback will return true
    isInline: () => !!inlineInput,
    // @ts-ignore
    ...inlineInput
  };
};
var normalizeInline = (inlineInput) => ({
  isInline: () => false,
  scrollIntoView: (elem) => elem.scrollIntoViewIfNeeded ? elem.scrollIntoViewIfNeeded() : elem.scrollIntoView(),
  context: "browser",
  params: {},
  ...inlineInput,
  // If a function is passed, it will be used as the callback.
  // If undefined, the callback will return true if it's the last element in the array.
  // Otherwise, it will return true if inline is true.
  shouldScroll: typeof inlineInput.shouldScroll === "function" ? inlineInput.shouldScroll : typeof inlineInput.shouldScroll === "undefined" ? (ctx, index, arr, defaultCallback) => defaultCallback(ctx, index, arr) : () => !!inlineInput.shouldScroll
});

// node_modules/@roxi/routify/lib/runtime/renderer/utils/normalizeDecorator.js
var decoratorDefaults = { recursive: true, shouldRender: () => true };
var normalizeDecorator = (decorator) => {
  if ("component" in decorator)
    return { ...decoratorDefaults, ...decorator };
  else
    return { ...decoratorDefaults, component: decorator };
};

// node_modules/@roxi/routify/lib/runtime/renderer/RenderContext.js
var shiftParams = (node2, pool) => {
  const params2 = {};
  node2.paramKeys.forEach((key) => {
    if (pool && key in pool) {
      params2[key] = pool[key].shift();
    }
  });
  return params2;
};
var RouterContext = class {
  /** @param {{router: Router}} params */
  constructor({ router }) {
    /** @type {import('svelte/store').Writable<RenderContext[]>} */
    __publicField(this, "childContexts", writable([]));
    /** @type {import('svelte/store').Writable<RouteFragment[]>} */
    __publicField(this, "childFragments", writable([]));
    /** @type {import('svelte/store').Writable<RenderContext>} */
    __publicField(this, "activeChildContext", writable(null));
    /** @type {RenderContext} */
    __publicField(this, "lastActiveChildContext", null);
    /** @type {Decorator[]} */
    __publicField(this, "decorators", []);
    this.router = router;
    this.route = router.activeRoute.get();
  }
  /**
   * @param {Partial<{inline: InlineInput, decorator:DecoratorInput, props, options, anchor: AnchorLocation, scrollBoundary: scrollBoundary}>} options
   *
   * */
  buildChildContexts(options, newDecorators) {
    var _a;
    const { childFragments } = this;
    const {
      inline: rawInlineInputFromSlot,
      decorator,
      props,
      anchor: anchorLocation,
      options: contextOptions,
      scrollBoundary = defaultscrollBoundary
    } = options;
    const refNode = (_a = get_store_value(childFragments)[0]) == null ? void 0 : _a.node;
    const parentNode = (this == null ? void 0 : this["node"]) || refNode.parent;
    const matches = parentNode ? parentNode.children.filter((node2) => node2 === refNode || nodeIsIndexed(node2)) : [refNode];
    const children2 = matches.length ? matches : [refNode];
    const paramsPool = jsonClone((rawInlineInputFromSlot == null ? void 0 : rawInlineInputFromSlot["params"]) || {});
    Object.entries(paramsPool).forEach(([key, values]) => {
      const index = children2.findIndex((node2) => node2.paramKeys.includes(key));
      const newChildren = new Array(values.length - 1).fill(children2[index]);
      children2.splice(index + 1, 0, ...newChildren);
    });
    const childContexts = children2.map(
      (node2) => new RenderContext({
        node: node2,
        paramsPool,
        rawInlineInputFromSlot,
        parentContext: this,
        newDecorators,
        contextOptions,
        scrollBoundary,
        anchorLocation
      })
    );
    this.childContexts.set(childContexts);
  }
  updateChildren() {
    const activeChildContext = get_store_value(this.activeChildContext);
    get_store_value(this.childContexts).forEach((context2) => context2.update(activeChildContext));
  }
};
var RenderContext = class _RenderContext extends RouterContext {
  /**
   *
   * @param {{
   *   node: RNodeRuntime
   *   paramsPool: Object.<string, string[]>
   *   rawInlineInputFromSlot: InlineInput
   *   parentContext: RenderContext | RouterContext
   *   newDecorators: Decorator[]
   *   contextOptions: RenderContextOptions
   *   scrollBoundary: scrollBoundary
   *   anchorLocation: AnchorLocation
   *   router?: Router
   * }} param0
   */
  constructor({
    node: node2,
    paramsPool,
    rawInlineInputFromSlot,
    parentContext,
    newDecorators,
    contextOptions,
    scrollBoundary,
    anchorLocation,
    router
  }) {
    super({ router: router || parentContext.router });
    __publicField(this, "anchorLocation", "parent");
    /** @type {RNodeRuntime} */
    __publicField(this, "node");
    __publicField(this, "isActive", writable(false));
    __publicField(this, "isVisible", writable(false));
    __publicField(this, "wasVisible", false);
    __publicField(this, "isInline", false);
    /** @type {Inline} */
    __publicField(this, "inline");
    /** @type {import('svelte/store').Writable<{ parent: HTMLElement, anchor: HTMLElement }>} */
    __publicField(this, "elem", writable(null));
    /** @type {Route} */
    __publicField(this, "route");
    /** @type {import('svelte/store').Writable<RenderContext[]>} */
    __publicField(this, "childContexts", writable([]));
    __publicField(this, "onDestroy", createSequenceHooksCollection());
    __publicField(this, "mounted", createDeferredPromise());
    /** @type {RouterContext} */
    __publicField(this, "routerContext");
    const { route } = parentContext;
    this.anchorLocation = anchorLocation || "parent";
    this.childFragments = writable(
      fetchIndexNode(node2) ? [new RouteFragment(route, fetchIndexNode(node2))] : []
    );
    this.node = node2;
    const params2 = shiftParams(node2, paramsPool);
    this.fragment = new RouteFragment(route, node2, null, params2);
    this.inline = normalizeInline({
      ...coerceInlineInputToObject(rawInlineInputFromSlot),
      ...coerceInlineInputToObject(node2.meta.inline)
    });
    if (parentContext instanceof _RenderContext) {
      this.routerContext = parentContext.routerContext;
      this.parentContext = parentContext;
    } else
      this.routerContext = parentContext;
    this.decorators = newDecorators;
    this.options = contextOptions || {};
    this.scrollBoundary = scrollBoundary;
  }
  get parentOrRouterContext() {
    return this.parentContext || this.routerContext;
  }
  setToActive() {
    const parentContext = this.parentOrRouterContext;
    const [fragment, ...fragments] = get_store_value(parentContext.childFragments);
    this.fragment = fragment;
    this.childFragments.set(fragments);
    this.route = parentContext.route;
    fragment.renderContext.resolve(this);
    parentContext.lastActiveChildContext = get_store_value(parentContext.activeChildContext);
    parentContext.activeChildContext.set(this);
    this.isInline = this.inline.isInline(this.node, this);
  }
  update(activeSiblingContext) {
    const environment = typeof window !== "undefined" ? "browser" : "ssr";
    this.isInline = this.inline.isInline(this.node, activeSiblingContext);
    const activeContextIsStandalone = activeSiblingContext && !activeSiblingContext.isInline;
    const envIsOkay = ["always", environment].includes(this.inline.context);
    const isIncluded = this.isInline && !activeContextIsStandalone && envIsOkay;
    const isDefault = !activeSiblingContext && this.node.name === "index";
    this.wasVisible = get_store_value(this.isVisible);
    lazySet(this.isActive, this === activeSiblingContext);
    lazySet(this.isVisible, get_store_value(this.isActive) || isIncluded || isDefault);
    if (!get_store_value(this.isVisible))
      this.elem.set(null);
  }
};

// node_modules/@roxi/routify/lib/runtime/renderer/composeFragments.js
var contextHasMatchingFragmentAndParams = (f) => (c) => f.node === c.node && Object.entries(f.params).every(([key, value]) => c.fragment.params[key] === value);
var nodeIsIndexed = (node2) => {
  var _a;
  return !node2.meta.fallback && !node2.name.startsWith("_") && ((_a = node2.meta) == null ? void 0 : _a.order) !== false;
};
var fetchIndexNode = (node2) => node2.children.find((node3) => node3.name === "index");
var findDecorator = (node2) => node2 == null ? void 0 : node2.children.find((node3) => node3.name === "_decorator");
var addFolderDecorator = (decorators, context2) => {
  const folderDecorator = findDecorator(context2.node);
  if (!folderDecorator)
    return;
  if (!folderDecorator.module)
    return folderDecorator.loadModule().then(() => {
      console.warn(`Dynamic import of "${folderDecorator.id}" may cause issues.`);
      addFolderDecorator(decorators, context2);
    });
  const options = folderDecorator.module["decorator"] || {};
  decorators.push({
    component: folderDecorator.module["default"],
    recursive: options.recursive ?? folderDecorator.meta.recursive ?? true,
    shouldRender: options.shouldRender ?? (() => true)
  });
};
function findNearestInlineContext(context2) {
  return context2 ? context2.isInline ? context2 : findNearestInlineContext(context2.parentContext) : null;
}
var defaultscrollBoundary = (ownContext) => {
  var _a, _b;
  return !ownContext.isInline && ((_b = get_store_value((_a = findNearestInlineContext(ownContext)) == null ? void 0 : _a.elem)) == null ? void 0 : _b.parent);
};
var findActiveChildContext = (childContexts, fragment) => childContexts.find(contextHasMatchingFragmentAndParams(fragment)) || childContexts.find((s) => s.node === (fragment == null ? void 0 : fragment.node));

// node_modules/@roxi/routify/lib/runtime/renderer/ComposeFragments.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[0] = list[i];
  return child_ctx;
}
function create_if_block5(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*$childContexts*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*context*/
    ctx2[0]
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$childContexts, props*/
      20) {
        each_value = ensure_array_like_dev(
          /*$childContexts*/
          ctx2[2]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(66:0) {#if decoratorReady}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let first;
  let renderfragment;
  let current;
  renderfragment = new RenderFragment_default({
    props: {
      context: (
        /*context*/
        ctx[0]
      ),
      props: (
        /*props*/
        ctx[4]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(renderfragment.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(renderfragment.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(renderfragment, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const renderfragment_changes = {};
      if (dirty & /*$childContexts*/
      4)
        renderfragment_changes.context = /*context*/
        ctx[0];
      renderfragment.$set(renderfragment_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(renderfragment.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(renderfragment.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      destroy_component(renderfragment, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(67:4) {#each $childContexts as context (context)}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*decoratorReady*/
    ctx[1] && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*decoratorReady*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*decoratorReady*/
          2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  var _a;
  let $childFragments;
  let $childContexts;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ComposeFragments", slots, []);
  let { context: context2 } = $$props;
  let { options } = $$props;
  const { childFragments } = context2;
  validate_store(childFragments, "childFragments");
  component_subscribe($$self, childFragments, (value) => $$invalidate(7, $childFragments = value));
  const { decorator, props } = options;
  const recursiveDecorators = context2.decorators.filter((deco) => deco.recursive);
  const newDecorators = pushToOrReplace(recursiveDecorators, decorator).filter(Boolean).map(normalizeDecorator);
  let decoratorReady = !((_a = addFolderDecorator(newDecorators, context2)) == null ? void 0 : _a["then"](() => $$invalidate(1, decoratorReady = true)));
  context2.buildChildContexts(options, newDecorators);
  const { childContexts } = context2;
  validate_store(childContexts, "childContexts");
  component_subscribe($$self, childContexts, (value) => $$invalidate(2, $childContexts = value));
  const _handleChildren = (childFragments2) => {
    const setInactive = (cf) => cf.renderContext.then((rc) => rc.isActive.set(false));
    if (childFragments2.length && context2.route)
      setActiveChildContext(context2);
    else
      childFragments2.forEach(setInactive);
    context2.updateChildren();
  };
  const setActiveChildContext = (context3, rebuild) => {
    const [fragment, ...childFragments2] = get_store_value(context3.childFragments);
    const childContexts2 = get_store_value(context3.childContexts);
    const toBeActiveChildContext = findActiveChildContext(childContexts2, fragment);
    if (!toBeActiveChildContext) {
      if (rebuild)
        handleRebuildError(context3, childContexts2);
      context3.buildChildContexts(options, newDecorators);
      return setActiveChildContext(context3, true);
    }
    toBeActiveChildContext.setToActive();
    context3.childContexts.set(childContexts2);
  };
  $$self.$$.on_mount.push(function() {
    if (context2 === void 0 && !("context" in $$props || $$self.$$.bound[$$self.$$.props["context"]])) {
      console.warn("<ComposeFragments> was created without expected prop 'context'");
    }
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<ComposeFragments> was created without expected prop 'options'");
    }
  });
  const writable_props = ["context", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ComposeFragments> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    get: get_store_value,
    pushToOrReplace,
    RenderFragment: RenderFragment_default,
    normalizeDecorator,
    handleRebuildError,
    addFolderDecorator,
    findActiveChildContext,
    context: context2,
    options,
    childFragments,
    decorator,
    props,
    recursiveDecorators,
    newDecorators,
    decoratorReady,
    childContexts,
    _handleChildren,
    setActiveChildContext,
    $childFragments,
    $childContexts
  });
  $$self.$inject_state = ($$props2) => {
    if ("context" in $$props2)
      $$invalidate(0, context2 = $$props2.context);
    if ("options" in $$props2)
      $$invalidate(6, options = $$props2.options);
    if ("decoratorReady" in $$props2)
      $$invalidate(1, decoratorReady = $$props2.decoratorReady);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$childFragments*/
    128) {
      $:
        _handleChildren($childFragments);
    }
  };
  return [
    context2,
    decoratorReady,
    $childContexts,
    childFragments,
    props,
    childContexts,
    options,
    $childFragments
  ];
}
var ComposeFragments = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { context: 0, options: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ComposeFragments",
      options,
      id: create_fragment7.name
    });
  }
  get context() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set context(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<ComposeFragments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<ComposeFragments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ComposeFragments_default = ComposeFragments;

// node_modules/@roxi/routify/lib/runtime/Router/Router.svelte
function create_if_block6(ctx) {
  let component;
  let current;
  component = new ComposeFragments_default({
    props: {
      context: (
        /*context*/
        ctx[2]
      ),
      options: { decorator: (
        /*decorator*/
        ctx[0]
      ) }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(component.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(component.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(component, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const component_changes = {};
      if (dirty & /*context*/
      4)
        component_changes.context = /*context*/
        ctx2[2];
      if (dirty & /*decorator*/
      1)
        component_changes.options = { decorator: (
          /*decorator*/
          ctx2[0]
        ) };
      component.$set(component_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(component.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(component.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(component, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(132:4) {#if $activeRoute}",
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*$activeRoute*/
    ctx[3] && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*$activeRoute*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$activeRoute*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block6(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: '(131:0) <AnchorDecorator onMount={initialize} style=\\"display: contents\\" location={anchor}>',
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let anchordecorator;
  let current;
  anchordecorator = new AnchorDecorator_default({
    props: {
      onMount: (
        /*initialize*/
        ctx[5]
      ),
      style: "display: contents",
      location: (
        /*anchor*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(anchordecorator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(anchordecorator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(anchordecorator, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const anchordecorator_changes = {};
      if (dirty & /*anchor*/
      2)
        anchordecorator_changes.location = /*anchor*/
        ctx2[1];
      if (dirty & /*$$scope, context, decorator, $activeRoute*/
      134217741) {
        anchordecorator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      anchordecorator.$set(anchordecorator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(anchordecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(anchordecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(anchordecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let activeRoute2;
  let $activeRoute, $$unsubscribe_activeRoute = noop, $$subscribe_activeRoute = () => ($$unsubscribe_activeRoute(), $$unsubscribe_activeRoute = subscribe(activeRoute2, ($$value) => $$invalidate(3, $activeRoute = $$value)), activeRoute2);
  $$self.$$.on_destroy.push(() => $$unsubscribe_activeRoute());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Router", slots, []);
  let { router = null } = $$props;
  let { routes = null } = $$props;
  let { decorator = null } = $$props;
  let { urlReflector = null } = $$props;
  let { instance: instance8 = null } = $$props;
  let { urlRewrite = null } = $$props;
  let { url: url2 = null } = $$props;
  let { name = null } = $$props;
  let { rootNode = null } = $$props;
  let { passthrough = null } = $$props;
  let { beforeRouterInit = null } = $$props;
  let { afterRouterInit = null } = $$props;
  let { beforeUrlChange: beforeUrlChange2 = null } = $$props;
  let { afterUrlChange: afterUrlChange2 = null } = $$props;
  let { transformFragments = null } = $$props;
  let { onDestroy: onDestroy2 = null } = $$props;
  let { plugins = null } = $$props;
  let { queryHandler = null } = $$props;
  let { anchor = "wrapper" } = $$props;
  let { clickHandler = {} } = $$props;
  const options = {
    instance: instance8,
    rootNode,
    name,
    routes,
    urlRewrite,
    urlReflector,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler,
    clickHandler
  };
  router = router || new Router(options);
  const context2 = new RouterContext({ router });
  router.onMount.run({ context: context2, router });
  context2.decorators = context2.decorators.map(normalizeDecorator);
  const initialize = (elem) => {
    var _a;
    elem = anchor === "parent" || anchor === "wrapper" ? elem : elem.parentElement;
    router.setParentElem(elem);
    elem["__routify_meta"] = { ...elem["__routify_meta"], router };
    let clickScopeElem = resolveIfAnonFn(((_a = router.clickHandler) == null ? void 0 : _a.elem) || elem, [elem]);
    if (!router.passthrough) {
      clickScopeElem.addEventListener("click", handleClick);
      clickScopeElem.addEventListener("keydown", handleClick);
      clickScopeElem.addEventListener("mouseover", handleHover);
    }
  };
  const handleHover = (event) => {
    var _a, _b, _c;
    let { url: url3, state } = getUrlFromEvent(event);
    const urlOrFalse = ((_b = (_a = router.clickHandler).callback) == null ? void 0 : _b.call(_a, event, url3)) ?? url3;
    const shouldPrefetch = typeof urlOrFalse === "string" && ((_c = event.target.closest("[data-routify-prefetch-data]")) == null ? void 0 : _c.dataset.routifyPrefetchData) === "hover";
    if (shouldPrefetch)
      router.url.push(urlOrFalse, { prefetch: true, ...state });
  };
  const handleClick = (event) => {
    var _a, _b;
    if (shouldIgnoreClick(event))
      return;
    const { url: eventUrl, state } = getUrlFromEvent(event);
    const url3 = ((_b = (_a = router.clickHandler).callback) == null ? void 0 : _b.call(_a, event, eventUrl)) ?? eventUrl;
    if (typeof url3 === "string")
      router.url.push(url3, state);
  };
  if (typeof window !== "undefined")
    onDestroy(() => router.destroy());
  const writable_props = [
    "router",
    "routes",
    "decorator",
    "urlReflector",
    "instance",
    "urlRewrite",
    "url",
    "name",
    "rootNode",
    "passthrough",
    "beforeRouterInit",
    "afterRouterInit",
    "beforeUrlChange",
    "afterUrlChange",
    "transformFragments",
    "onDestroy",
    "plugins",
    "queryHandler",
    "anchor",
    "clickHandler"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Router> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(6, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance8 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
    if ("anchor" in $$props2)
      $$invalidate(1, anchor = $$props2.anchor);
    if ("clickHandler" in $$props2)
      $$invalidate(23, clickHandler = $$props2.clickHandler);
  };
  $$self.$capture_state = () => ({
    Router,
    _onDestroy: onDestroy,
    getUrlFromEvent,
    resolveIfAnonFn,
    shouldIgnoreClick,
    Component: ComposeFragments_default,
    get: get_store_value,
    AnchorDecorator: AnchorDecorator_default,
    normalizeDecorator,
    RouterContext,
    router,
    routes,
    decorator,
    urlReflector,
    instance: instance8,
    urlRewrite,
    url: url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange: beforeUrlChange2,
    afterUrlChange: afterUrlChange2,
    transformFragments,
    onDestroy: onDestroy2,
    plugins,
    queryHandler,
    anchor,
    clickHandler,
    options,
    context: context2,
    initialize,
    handleHover,
    handleClick,
    activeRoute: activeRoute2,
    $activeRoute
  });
  $$self.$inject_state = ($$props2) => {
    if ("router" in $$props2)
      $$invalidate(6, router = $$props2.router);
    if ("routes" in $$props2)
      $$invalidate(7, routes = $$props2.routes);
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("urlReflector" in $$props2)
      $$invalidate(8, urlReflector = $$props2.urlReflector);
    if ("instance" in $$props2)
      $$invalidate(9, instance8 = $$props2.instance);
    if ("urlRewrite" in $$props2)
      $$invalidate(10, urlRewrite = $$props2.urlRewrite);
    if ("url" in $$props2)
      $$invalidate(11, url2 = $$props2.url);
    if ("name" in $$props2)
      $$invalidate(12, name = $$props2.name);
    if ("rootNode" in $$props2)
      $$invalidate(13, rootNode = $$props2.rootNode);
    if ("passthrough" in $$props2)
      $$invalidate(14, passthrough = $$props2.passthrough);
    if ("beforeRouterInit" in $$props2)
      $$invalidate(15, beforeRouterInit = $$props2.beforeRouterInit);
    if ("afterRouterInit" in $$props2)
      $$invalidate(16, afterRouterInit = $$props2.afterRouterInit);
    if ("beforeUrlChange" in $$props2)
      $$invalidate(17, beforeUrlChange2 = $$props2.beforeUrlChange);
    if ("afterUrlChange" in $$props2)
      $$invalidate(18, afterUrlChange2 = $$props2.afterUrlChange);
    if ("transformFragments" in $$props2)
      $$invalidate(19, transformFragments = $$props2.transformFragments);
    if ("onDestroy" in $$props2)
      $$invalidate(20, onDestroy2 = $$props2.onDestroy);
    if ("plugins" in $$props2)
      $$invalidate(21, plugins = $$props2.plugins);
    if ("queryHandler" in $$props2)
      $$invalidate(22, queryHandler = $$props2.queryHandler);
    if ("anchor" in $$props2)
      $$invalidate(1, anchor = $$props2.anchor);
    if ("clickHandler" in $$props2)
      $$invalidate(23, clickHandler = $$props2.clickHandler);
    if ("activeRoute" in $$props2)
      $$subscribe_activeRoute($$invalidate(4, activeRoute2 = $$props2.activeRoute));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*url, router*/
    2112) {
      $:
        if (url2 && url2 !== router.url.internal())
          router.url.replace(url2);
    }
    if ($$self.$$.dirty & /*router*/
    64) {
      $:
        $$subscribe_activeRoute($$invalidate(4, activeRoute2 = router.activeRoute));
    }
    if ($$self.$$.dirty & /*$activeRoute*/
    8) {
      $:
        $$invalidate(2, context2.route = $activeRoute, context2);
    }
    if ($$self.$$.dirty & /*context, $activeRoute*/
    12) {
      $:
        context2.childFragments.set(($activeRoute == null ? void 0 : $activeRoute.fragments) || []);
    }
    if ($$self.$$.dirty & /*router, context*/
    68) {
      $:
        router.log.debug("before render", get_store_value(context2.childFragments));
    }
  };
  return [
    decorator,
    anchor,
    context2,
    $activeRoute,
    activeRoute2,
    initialize,
    router,
    routes,
    urlReflector,
    instance8,
    urlRewrite,
    url2,
    name,
    rootNode,
    passthrough,
    beforeRouterInit,
    afterRouterInit,
    beforeUrlChange2,
    afterUrlChange2,
    transformFragments,
    onDestroy2,
    plugins,
    queryHandler,
    clickHandler
  ];
}
var Router_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment8, safe_not_equal, {
      router: 6,
      routes: 7,
      decorator: 0,
      urlReflector: 8,
      instance: 9,
      urlRewrite: 10,
      url: 11,
      name: 12,
      rootNode: 13,
      passthrough: 14,
      beforeRouterInit: 15,
      afterRouterInit: 16,
      beforeUrlChange: 17,
      afterUrlChange: 18,
      transformFragments: 19,
      onDestroy: 20,
      plugins: 21,
      queryHandler: 22,
      anchor: 1,
      clickHandler: 23
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router_1",
      options,
      id: create_fragment8.name
    });
  }
  get router() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set router(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get routes() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set routes(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get decorator() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorator(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlReflector() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlReflector(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get instance() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set instance(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get urlRewrite() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set urlRewrite(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get url() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set url(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rootNode() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rootNode(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get passthrough() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set passthrough(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterRouterInit() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterRouterInit(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get beforeUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set beforeUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get afterUrlChange() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set afterUrlChange(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transformFragments() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transformFragments(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onDestroy() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onDestroy(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get plugins() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get queryHandler() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set queryHandler(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get clickHandler() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set clickHandler(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Router_default = Router_1;

// node_modules/@roxi/routify/lib/runtime/Router/urlReflectors/LocalStorage.js
var LocalStorageReflector = class extends BaseReflector {
  /** @param {Router} router */
  constructor(router) {
    super(router);
    this.storageName = `__routify-router-${this.router.name}`;
  }
  reflect() {
    window.localStorage.setItem(this.storageName, this.router.url.internal());
  }
  install() {
    const url2 = window.localStorage.getItem(this.storageName);
    this.router.url.replace(url2 || "/");
  }
};

// node_modules/@roxi/routify/lib/common/helpers.js
var gentleAssign = (target, ...sources) => {
  sources.forEach(
    (source) => Object.keys(source).forEach((key) => target[key] = target[key] ?? source[key])
  );
  return target;
};
var assignNode = (target, ...sources) => {
  gentleAssign(target, ...sources);
  gentleAssign(target.meta, ...sources.map((s) => s.meta));
  sources.forEach((source) => {
    source.children.forEach((sNode) => {
      let tNode = target.children.find((tNode2) => tNode2.name === sNode.name);
      if (!tNode)
        tNode = target.createChild(null, null);
      assignNode(tNode, sNode);
    });
  });
  return target;
};
var findNearestParent = (node2, callback) => {
  let parent = (
    /** @type {RNodeRuntime} */
    node2.parent
  );
  while (parent) {
    if (callback(parent))
      return parent;
    parent = parent.parent;
  }
};
var getDistance = (parentNode, childNode) => {
  let child = null;
  let distance = 0;
  while (child = childNode.parent) {
    distance++;
    if (parentNode === childNode)
      return distance;
  }
};

// node_modules/@roxi/routify/lib/runtime/index.js
var Routify2 = RoutifyRuntime;
export {
  AddressReflector,
  ComposeFragments_default as Component,
  InternalReflector,
  LocalStorageReflector,
  Router_default as Router,
  Router as RouterClass,
  Routify2 as Routify,
  _url,
  activeRoute,
  afterUrlChange,
  appInstance,
  assignNode,
  beforeUrlChange,
  context,
  createRouter,
  createUrl,
  findNearestParent,
  getDistance,
  getMRCA,
  getPath,
  getPrimaryUrl,
  goto,
  isActive,
  isActiveUrl,
  meta,
  node,
  params,
  pendingRoute,
  preloadUrl,
  preloadUrlFromUrlPairs,
  resolveNode,
  traverseNode,
  url
};
//# sourceMappingURL=@roxi_routify.js.map
